# Language Server Protocol (LSP)

**Purpose:** Real-time IDE features for macro-based language

**Performance Target:** <100ms for all operations, <200ms for macro-heavy files

---

## The Macro Challenge

Traditional LSP queries the **source AST**. Metascript must query the **expanded AST**:

```typescript
@derive(Eq)
class User { name: string; }

const user = new User();
user.| // cursor here

// Source AST: Only name visible
// Expanded AST: name + equals() visible!
```

**Without macro-aware LSP:** Users can't discover generated methods.
**With macro-aware LSP:** "It just works."

---

## Architecture

```
Editor → JSON-RPC → LSP Server → Trans-Am Query Engine
                                       │
                    ┌──────────────────┴───────────────┐
                    │                                   │
              Parse Query              Macro Expand Query
              (cached)                 (content-addressed)
                    │                         │
                    └─────────┬───────────────┘
                              ↓
                        Expanded AST
                              │
                              ↓
                        TypeChecker
                              │
                    ┌─────────┴─────────┐
                    │                   │
              Completions          Hover Info
```

---

## Key Features

### Hover on Expanded Code

```typescript
@derive(Eq)
class User { name: string; }
//     ^ Hover shows: "Generated by @derive macro"
```

```zig
pub fn onHover(lsp: *LSPServer, uri: []const u8, pos: Position) !HoverResult {
    const doc = lsp.documents.get(uri).?;
    const node = findNodeAtPosition(doc.ast, pos);

    if (node.expansion_origin) |origin| {
        return .{
            .contents = try std.fmt.allocPrint(
                "Generated by @{s} macro\nOriginal: {s}",
                .{ origin.macro_name, formatNode(origin.original_ast) }
            ),
        };
    }

    if (node.type) |type_info| {
        return .{ .contents = formatType(type_info) };
    }
}
```

### Completion with Generated Members

```typescript
user.| // shows: name, equals (from @derive)
```

Query the **expanded AST** for completions, not source AST.

### Macro Expansion Preview

```
Command: "Show Macro Expansion"

@derive(Eq, Hash)
class User { name: string; }

// Expands to:
class User {
    name: string;
    equals(other: User): boolean { ... }
    hashCode(): number { ... }
}
```

---

## Performance Targets

| Feature | Target | Max |
|---------|--------|-----|
| Syntax highlighting | <5ms | 16ms |
| Token highlighting | <5ms | 16ms |
| Hover (static) | <50ms | 100ms |
| Completion (no macros) | <100ms | 200ms |
| Completion (with macros) | <200ms | 500ms |
| Go-to-definition | <50ms | 100ms |
| Diagnostics (file) | <500ms | 1s |
| Macro expansion preview | <500ms | 1s |

---

## Five-Level Cache Hierarchy

```
LEVEL 1: Bytecode Cache (Disk)
  .metascript-cache/macros/<hash>.hbc
  Compiled Hermes bytecode
  Persists across sessions

LEVEL 2: Macro Output Cache (Memory)
  TransAmDatabase.macro_output_cache
  Expanded AST keyed by input hash
  LRU bounded (2000 entries)

LEVEL 3: Type Cache (Memory)
  Type annotations on expanded AST
  LRU bounded (2000 entries)

LEVEL 4: Completion Cache (Memory)
  Pre-computed completion lists
  LRU bounded (500 entries)

LEVEL 5: Network Cache (Disk)
  @comptime fetch() responses
  TTL-based (default 24h)
```

---

## Cancellation Strategy

When user types, cancel outdated work:

```zig
pub const TransAmDatabase = struct {
    cancellation_version: std.atomic.Value(u64),

    pub fn cancelPendingQueries(self: *@This()) void {
        _ = self.cancellation_version.fetchAdd(1, .seq_cst);
    }

    pub fn unwindIfCancelled(self: *@This(), starting: u64) !void {
        if (self.cancellation_version.load(.seq_cst) != starting) {
            return error.QueryCancelled;
        }
    }
};
```

**Key insight:** Long queries periodically check cancellation and abort.

---

## Stale-While-Revalidate

Return stale results immediately, update in background:

```
User edits → Return STALE (0ms) → Background: re-expand → Update

✅ User sees instant response
✅ Stale data 99% correct (missing only new changes)
✅ Fresh data arrives in ~70ms silently
```

---

## Implementation Status

### Infrastructure (Done)

| Feature | Status |
|---------|--------|
| Trans-Am query engine | Done |
| LRU caches (L2-L4) | Done |
| Cancellation | Done |
| Parse caching | Done |
| Macro expansion caching | Done |
| Type cache integration | Done |
| Completion cache | Done |
| Background worker | Done |

### LSP Features

| Feature | Status | Priority | Notes |
|---------|--------|----------|-------|
| Hover | Done | - | Keywords, types, macro preview |
| Completion (keywords) | Done | - | Static keyword list |
| **Completion (dot/member)** | TODO | Critical | `obj.` shows properties/methods |
| Go-to Definition | Done | - | Source symbols |
| **Go-to Definition (generated)** | TODO | Medium | Navigate to macro-generated code |
| Document Symbols | Done | - | Lexer-based outline |
| Semantic Tokens | Done | - | Syntax highlighting |
| Diagnostics | Done | - | Parse + type errors |
| **Signature Help** | TODO | High | Parameter hints on `foo(|)` |
| **Find References** | TODO | Medium | All usages of symbol |
| **Rename Symbol** | TODO | Medium | Safe multi-file rename |
| **Inlay Hints** | TODO | Medium | Inline type annotations |
| **Code Actions** | TODO | Medium | Quick fixes, refactorings |
| **Workspace Symbols** | TODO | Medium | Project-wide symbol search |
| **Formatting** | TODO | Low | Code formatting |
| **Folding Ranges** | TODO | Low | Code folding |
| **Document Highlights** | TODO | Low | Highlight occurrences |

### Macro Integration

| Feature | Status | Notes |
|---------|--------|-------|
| TypeChecker on expanded AST | Partial | Needs verification |
| Completions from expanded AST | Partial | Dot completion missing |
| Hover shows macro origin | Partial | Preview works, `expansion_origin` not on AST |
| `expansion_origin` on AST nodes | TODO | Required for proper error messages |

---

## TODO: Feature Implementation Details

### Phase 1: Critical Path (Maximum Impact)

#### 1. Dot/Member Completion
**Priority:** Critical
**Impact:** #1 most-used IDE feature

```typescript
const user = new User();
user.|  // Should show: name, equals() (from @derive), etc.
```

**Implementation:**
- Detect cursor after `.` token
- Get expression type before dot via Trans-Am
- Query symbol table for members of that type
- Include macro-generated members from expanded AST

#### 2. Signature Help
**Priority:** High
**Impact:** Reduces cognitive load, fewer doc lookups

```typescript
Math.pow(|)  // Should show: (x: number, y: number): number
```

**Implementation:**
- Detect cursor inside function call `(`
- Find function being called
- Return parameter names and types

---

### Phase 2: Refactoring Support

#### 3. Find References
**Priority:** Medium
**Impact:** Essential for refactoring

**Implementation:**
- Scan all open files for symbol usage
- Use symbol table for scope-aware matching
- Handle macro-generated references

#### 4. Rename Symbol
**Priority:** Medium
**Impact:** Major refactoring capability

**Implementation:**
- Find all references (above)
- Apply edits atomically
- Handle macro-generated code (warn user)

---

### Phase 3: Developer Experience Polish

#### 5. Inlay Hints
**Priority:** Medium
**Impact:** TypeScript developers expect this

```typescript
const x = 42;  // Shows: `: number` inline
```

#### 6. Code Actions
**Priority:** Medium
**Impact:** Quick fixes and refactorings

- "Add missing import"
- "Generate equals/hashCode"
- "Convert to arrow function"

#### 7. Workspace Symbols
**Priority:** Medium
**Impact:** Project-wide navigation (`Ctrl+T`)

---

## Technical Debt

| Issue | Impact | Status | Notes |
|-------|--------|--------|-------|
| Re-lexing on every request | Low | Deferred | Lexer is fast (<5ms), Trans-Am caches syntax tokens |
| No AST caching for completion | Low | Deferred | Parse cache exists, completion uses it |
| Completion ignores position context | High | TODO | Blocks dot completion - needs expression type inference |
| Document symbols uses lexer | Medium | Deferred | Works correctly, AST would add hierarchy support |
| Hardcoded Math/console hover | Low | Deferred | Needs stdlib type definitions |

**Analysis:** The "re-lexing" items are low priority because lexing is very fast. The critical gap is **position context for completion** which blocks the dot/member completion feature.

---

## Testing Strategy

### Unit Tests

```zig
test "LSP hover shows macro origin" {
    const source = "@derive(Eq) class User {}";
    const hover = lsp.onHover(source, Position{ .line = 0, .col = 20 });
    try testing.expect(std.mem.indexOf(u8, hover.contents, "@derive") != null);
}

test "LSP completion includes generated methods" {
    const source = "@derive(Eq) class User { name: string; }\nlet u = new User(); u.|";
    const completions = lsp.onCompletion(source, Position{ .line = 1, .col = 22 });
    try testing.expect(hasCompletion(completions, "equals"));
}
```

### Performance Tests

- 1000+ macro classes: Still <200ms completion
- Rapid typing: No queued unbounded work
- Memory: <150MB total cache

---

## File Location

```
src/lsp/
  server.zig           # Main LSP server
  hover.zig            # Hover provider
  completion.zig       # Completion provider
  diagnostics.zig      # Diagnostic provider
  background_worker.zig # Background job queue

src/transam/
  transam.zig          # Query engine
  cache.zig            # LRU caches
  network_cache.zig    # Network response cache
```

---

## References

- **rust-analyzer:** Query engine patterns
- **Trans-Am architecture:** `./trans-am.md`
- **Full LSP design:** `../lsp-architecture.md`
- **Implementation details:** `../lsp-implementation.md`
