# Runtime Library

**Purpose:** Memory management and built-in types for C backend

**Key Components:** ORC (reference counting), string, allocator

---

## Overview

| Component | Purpose |
|-----------|---------|
| **ORC** | Reference counting with cycle detection |
| **msString** | UTF-8 string type |
| **Allocator** | Memory allocation interface |

---

## ORC (Optimized Reference Counting)

Based on Nim ORC + Lobster ownership model.

### RefHeader (8 bytes)

Every heap object has a header:

```zig
pub const RefHeader = packed struct {
    rc: u32,         // Reference count
    flags: Flags,    // 1 byte (color, buffered, visited)
    type_id: u24,    // Type registry lookup for cycle tracing
};

pub const Flags = packed struct {
    color: Color,    // 2 bits: black, purple, gray, white
    buffered: bool,  // Already in cycle roots list
    visited: bool,   // Visited during traversal
    _pad: u4,        // Reserved
};
```

### Color Semantics (Bacon-Rajan Algorithm)

| Color | Meaning |
|-------|---------|
| **Black** | In use or free (default) |
| **Purple** | Possible cycle root |
| **Gray** | Candidate for collection |
| **White** | Member of garbage cycle |

### ORCRuntime

```zig
pub const ORCRuntime = struct {
    allocator: std.mem.Allocator,
    roots: std.ArrayList(*RefHeader),
    type_registry: TypeRegistry,
    cycle_threshold: usize,
    stats: Stats,
    enable_cycles: bool,

    pub fn alloc(self: *ORCRuntime, comptime T: type) !*T;
    pub fn incref(self: *ORCRuntime, ptr: anytype) void;
    pub fn decref(self: *ORCRuntime, ptr: anytype) void;
    pub fn decrefTyped(self: *ORCRuntime, ptr: anytype, type_info: *const TypeInfo) !void;
    pub fn collectCycles(self: *ORCRuntime) !void;
};
```

### Usage Pattern

```zig
var orc = ORCRuntime.init(allocator);
defer orc.deinit();

// Allocate object
const user = try orc.alloc(User);
user.name = "Alice";

// Share reference
orc.incref(user);
other_container.user = user;

// Release reference (simple, acyclic)
orc.decref(user);

// Release reference (with cycle check)
try orc.decrefTyped(user, &User.type_info);
```

---

## TypeInfo

Static metadata for cycle detection:

```zig
pub const TypeInfo = struct {
    name: []const u8,          // Type name (debugging)
    size: usize,               // Size for allocation
    is_cyclic: bool,           // Can form cycles?
    trace_fn: ?*const fn(...), // Trace children
    destroy_fn: ?*const fn(...), // Destructor
};
```

### Compiler-Generated TypeInfo

```zig
// Generated by C backend for each class
const User_type_info = TypeInfo{
    .name = "User",
    .size = @sizeOf(User),
    .is_cyclic = true,  // Has reference fields
    .trace_fn = User_trace,
    .destroy_fn = User_destroy,
};

fn User_trace(obj: *anyopaque, callback: *const fn(*anyopaque) void) void {
    const user = @ptrCast(*User, obj);
    if (user.friend) |friend| callback(friend);
    if (user.manager) |manager| callback(manager);
}
```

---

## TypeRegistry

Maps type_id to TypeInfo:

```zig
pub const TypeRegistry = struct {
    const MAX_TYPES: usize = 4096;
    types: [MAX_TYPES]?*const TypeInfo,
    count: usize,

    pub fn register(self: *TypeRegistry, type_info: *const TypeInfo) u24;
    pub fn get(self: *const TypeRegistry, type_id: u24) ?*const TypeInfo;
};
```

---

## Cycle Collection

### Triggering

```zig
// Automatic: when roots exceed threshold
if (self.roots.items.len >= self.cycle_threshold) {
    try self.collectCycles();
}

// Manual
try orc.collectCycles();
```

### Algorithm (Bacon-Rajan)

```
1. Mark Roots (purple → gray)
   For each root with rc > 0:
     Trace children, decrement counts temporarily

2. Scan Gray
   For each gray object:
     If rc == 0: mark white (garbage)
     Else: mark black (reachable), restore counts

3. Collect White
   For each white object:
     Call destructor, free memory
```

---

## msString

UTF-8 encoded string with ORC:

```zig
pub const msString = struct {
    len: usize,      // Bytes (not code points)
    capacity: usize,
    data: [*]u8,     // Null-terminated

    pub fn new(allocator: Allocator, data: []const u8) !*msString;
    pub fn empty(allocator: Allocator) !*msString;
    pub fn concat(allocator: Allocator, a: *msString, b: *msString) !*msString;
    pub fn bytes(self: *const msString) []const u8;
    pub fn incref(self: *msString) void;
    pub fn decref(self: *msString, allocator: Allocator) void;
};
```

### Memory Layout

```
[RefHeader (8 bytes)][msString struct][UTF-8 bytes + null]
```

### Example

```zig
const allocator = std.heap.page_allocator;

var s1 = try msString.new(allocator, "Hello");
defer s1.decref(allocator);

var s2 = try msString.new(allocator, " World");
defer s2.decref(allocator);

var s3 = try msString.concat(allocator, s1, s2);
defer s3.decref(allocator);

// s3.bytes() == "Hello World"
```

---

## Statistics

Track runtime behavior:

```zig
pub const Stats = struct {
    allocations: u64,
    deallocations: u64,
    increfs: u64,
    decrefs: u64,
    cycle_collections: u64,
    objects_scanned: u64,
    cycles_freed: u64,
    acyclic_fast_path: u64,  // Decrefs skipping cycle check
};
```

Access:
```zig
std.debug.print("Allocations: {}\n", .{orc.stats.allocations});
std.debug.print("Cycles freed: {}\n", .{orc.stats.cycles_freed});
```

---

## Performance Characteristics

| Operation | Cost |
|-----------|------|
| Allocation | O(1) + allocator |
| incref | O(1) |
| decref (acyclic) | O(1) |
| decref (cyclic, no cycle) | O(1) |
| Cycle collection | O(roots) |

### Optimization: Acyclic Fast Path

For types that can't form cycles (primitives, leaf classes):

```zig
// Compiler uses decref() directly - no cycle check
orc.decref(point);  // Point has no reference fields

// vs cyclic types
try orc.decrefTyped(user, &User.type_info);
```

---

## Integration with Lobster

Lobster analysis reduces RC operations at compile time:

```
Before Lobster: 100 incref + 100 decref
After Lobster:  15 incref + 15 decref (85% reduction)
```

| Analysis | Optimization |
|----------|--------------|
| **Ownership** | Skip incref for owned values |
| **Borrowing** | Skip all RC for borrowed refs |
| **Escape** | Stack allocate non-escaping |
| **Move** | Transfer ownership, no copy |

---

## File Structure

```
src/runtime/
  orc.zig                    # ORC runtime, RefHeader, TypeInfo
  string.zig                 # msString implementation
  orc_edge_cases_test.zig    # Edge case tests
  string_edge_cases_test.zig # String tests
```

---

## C Header Output

Generated `orc.h` for C backend:

```c
// orc.h (~720 LOC, header-only)
typedef struct {
    uint32_t rc;
    uint8_t flags;
    uint32_t type_id : 24;
} ms_RefHeader;

typedef struct {
    const char* name;
    size_t size;
    bool is_cyclic;
    void (*trace_fn)(void*, void (*)(void*));
    void (*destroy_fn)(void*);
} ms_TypeInfo;

void ms_incref(void* ptr);
void ms_decref(void* ptr);
void ms_decref_typed(void* ptr, const ms_TypeInfo* type_info);
void ms_collect_cycles(void);
```

---

## Testing

```bash
zig build test -- --test-filter="orc"
zig build test -- --test-filter="string"
```

```zig
test "ORC: cycle detection" {
    var orc = ORCRuntime.init(testing.allocator);
    defer orc.deinit();

    // Create cycle: A → B → A
    const a = try orc.alloc(Node);
    const b = try orc.alloc(Node);
    a.next = b;
    b.next = a;
    orc.incref(b);  // A references B
    orc.incref(a);  // B references A

    // Release external references
    try orc.decrefTyped(a, &Node.type_info);
    try orc.decrefTyped(b, &Node.type_info);

    // Force cycle collection
    try orc.collectCycles();

    // Both should be freed (cycles_freed > 0)
    try testing.expect(orc.stats.cycles_freed >= 2);
}
```

---

## Global Builtins & Stdlib

### Design Principles

1. **Global builtins** (Math, Array, console) - no import, TypeScript compatible
2. **Stdlib modules** (`std/`) - explicit import, cross-backend
3. **Backend-specific** (`c/`, `erl/`, `js/`) - explicit import, single backend

### Module Prefix Convention

| Prefix | Scope | Example |
|--------|-------|---------|
| *(none)* | Global builtins | `Math.floor()`, `console.log()` |
| `std/` | Cross-backend stdlib | `import { readFile } from 'std/fs'` |
| `c/` | C backend only | `import { mmap } from 'c/posix'` |
| `erl/` | Erlang only | `import { GenServer } from 'erl/otp'` |
| `js/` | JS only | `import { document } from 'js/dom'` |

### Global Builtins

No import required - matches TypeScript behavior:

```typescript
const x = Math.floor(3.5);
const arr = [1, 2, 3];
arr.push(4);
console.log("hello");
```

**C Backend Mapping:**

| MetaScript | C Output | Header |
|------------|----------|--------|
| `Math.floor(x)` | `floor(x)` | `<math.h>` |
| `Math.sqrt(x)` | `sqrt(x)` | `<math.h>` |
| `Math.abs(x)` | `fabs(x)` | `<math.h>` |
| `Math.PI` | `M_PI` | `<math.h>` |
| `console.log(x)` | `printf(...)` | `<stdio.h>` |
| `arr.push(x)` | `ms_array_push(arr, x)` | `ms_array.h` |
| `arr.length` | `arr->len` | `ms_array.h` |

**Lazy Include:** Headers only included if builtin is actually used.

### msArray (Planned)

Dynamic array with ORC integration:

```c
typedef struct {
    size_t len;
    size_t capacity;
    ms_TypeInfo* element_type;
    void* data;  // Type-specific storage
} msArray;

msArray* ms_array_new(size_t capacity, ms_TypeInfo* elem_type);
void ms_array_push(msArray* arr, void* element);
void* ms_array_get(msArray* arr, size_t index);
size_t ms_array_len(msArray* arr);
void ms_array_free(msArray* arr);
```

### TypeScript Features NOT Supported (v1)

- `any` type
- `eval()` / `Function()` constructor
- Prototype manipulation (`__proto__`, `setPrototypeOf`)
- Dynamic `import()`
- `with` statement
- Runtime decorators (use `@derive` macros)

---

## References

- **Lobster optimizations:** `./lobster.md`
- **DRC analysis:** `./drc-orc.md`
- **C backend generation:** `./backends.md`
