# High-Performance LSP for Macro-Based Languages

**Goal:** <100ms responsiveness for syntax highlighting and LSP with dynamic macro expansion

**Key Insight:** Rust-analyzer (<100ms) and ZLS (300ms) prove macros + fast LSP are compatible. Nim (5-6s) and Haxe (800ms) prove wrong architecture creates unfixable ceiling.

---

## Performance Benchmarks

| Language | Latency | Memory | Architecture |
|----------|---------|--------|--------------|
| Rust-analyzer | <100ms | Moderate | Query engine (Salsa) |
| ZLS | <50ms syntax, 300ms semantic | Low | AST-first + build-on-save |
| Nim | 5-6s | 24GB leaks | Full compiler per request |
| Haxe | 800ms | Multi-GB | Fresh AST + macro re-expansion |

**Root Cause:**

```
âœ… Rust/Zig: LSP Server (Query Engine) â†’ Selective Compiler Queries â†’ Cached
âŒ Nim/Haxe: LSP Wrapper â†’ Full Compiler Invocation â†’ No Caching
```

**Critical Insight:** Invert dependency - compiler serves LSP, not vice versa.

---

## Architectural Decisions

### 1. Salsa Query Engine (Rust-Analyzer)

**How it works:**
- Parse, expand macro, infer type = separate queries
- Cache results by input fingerprint
- Invalidate only affected queries

**Example:**
```rust
#[derive(Serialize)]  // Macro cached
struct User {
    name: String,  // Edit here: only type inference re-runs (25ms)
}
```

**vs Nim:**
```nim
type User = object
  name: string  # Edit here: re-parse all imports + re-expand all macros (5s)
```

### 2. Build-on-Save Hybrid (ZLS)

**How it works:**
- AST parsing for syntax (instant)
- Full compiler for semantics (on save only)
- Cancellation model (discard stale analysis)

**Key:** Users accept 300ms delay on save, interactive features stay instant.

**vs Haxe:** Runs macros every keystroke (800ms overhead)

### 3. Macro Expansion Comparison

| Strategy | Frequency | Caching | Result |
|----------|-----------|---------|--------|
| Rust | On-demand | Yes | <100ms âœ“ |
| Zig | On-save | Partial | 300ms âœ“ |
| Nim | Every request | None | 5-6s âœ— |
| Haxe | Every completion | None | 800ms âœ— |

---

## CRITICAL: Macro-Aware LSP (The Holy Grail)

**Key Insight:** LSP must query the EXPANDED AST, not the source AST. This is non-negotiable for a macro-based language.

### The Problem

```
SOURCE CODE                      WHAT USER EXPECTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@derive(Eq)                      user.equals(other)  â† MUST autocomplete!
class User {                     user.name           â† obvious
    name: string;                user.age            â† obvious
}

const user = new User();
user.â–ˆ  â† cursor here
```

**If LSP queries pre-expansion AST:** Only `name` and `age` appear in completions.
**If LSP queries EXPANDED AST:** `equals()` also appears - generated by `@derive(Eq)`!

### The Haxe Example: Network-Fetched Schema â†’ Completions

```typescript
// Macro fetches OpenAPI spec at COMPILE-TIME
const api = @comptime {
    const schema = fetch("https://api.example.com/openapi.json");
    return generateTypedClient(schema);
};

api.â–ˆ  â† LSP shows getUsers(), getUserById(), createUser() from network data!
```

**This is the holy grail:** Compile-time code executes (can do I/O), generates AST, and LSP provides completions from that generated code.

### Architecture Required

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     LSP ON EXPANDED AST                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  Source        Trans-Am              LSP                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€        â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€                                 â”‚
â”‚                                                                          â”‚
â”‚  @derive(Eq)   Parse Query â”€â”€â”€â”€â”€â–º  Hover Request                        â”‚
â”‚  class User    (cached)            Completion Request                   â”‚
â”‚                    â”‚                    â”‚                                â”‚
â”‚                    â–¼                    â”‚                                â”‚
â”‚              Macro Expand  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚              Query                                                       â”‚
â”‚              (cached!)                                                   â”‚
â”‚                    â”‚                                                     â”‚
â”‚                    â–¼                                                     â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                â”‚
â”‚              â”‚HERMES VM â”‚                                                â”‚
â”‚              â”‚          â”‚                                                â”‚
â”‚              â”‚Execute   â”‚ â—„â”€â”€ Can do: fetch(), readFile(), exec()       â”‚
â”‚              â”‚derive.ms â”‚                                                â”‚
â”‚              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                                â”‚
â”‚                   â”‚                                                      â”‚
â”‚                   â–¼                                                      â”‚
â”‚              EXPANDED AST â—„â”€â”€ THIS is what LSP queries!                  â”‚
â”‚                   â”‚                                                      â”‚
â”‚                   â–¼                                                      â”‚
â”‚              TypeChecker â—„â”€â”€ Runs on EXPANDED, not source                â”‚
â”‚                   â”‚                                                      â”‚
â”‚                   â–¼                                                      â”‚
â”‚              Completions/Hover/GoTo â—„â”€â”€ From REAL generated members      â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementation Checklist

| Component | Status | Description |
|-----------|--------|-------------|
| Trans-Am Macro Cache | âœ… Done | Cache expanded AST by hash |
| Hermes VM Execution | âœ… Done | Execute macro code |
| LSP â†’ Trans-Am Query | ğŸš§ Partial | `getMacroExpansionHover` exists |
| **TypeChecker on Expanded** | âŒ Missing | Run type inference POST-expansion |
| **Completions from Expanded** | âŒ Missing | Query expanded AST for members |
| **Network I/O in @comptime** | âŒ Missing | `fetch()` in Hermes sandbox |
| Hover shows Expanded | ğŸš§ Partial | `formatMacroExpansion` exists |
| **Go-to-definition for generated** | âŒ Missing | Jump to macro source |

### Why This Matters

**Without macro-aware LSP:**
- Users can't discover macro-generated methods
- Refactoring breaks (can't find references to generated code)
- No hover docs for generated members
- IDE experience feels broken

**With macro-aware LSP:**
- Macros are first-class citizens
- Generated code is fully discoverable
- Network-fetched schemas get completions
- "It just works" experience

### Performance Considerations

```
Macro expansion: ~0.05ms (cached bytecode)
Type checking:   ~5-20ms (incremental)
LSP response:    <100ms target

Key: Trans-Am caching makes repeated queries instant
     Only re-expand when source OR macro changes
```

---

## Trans-Am: The Performance Gift (Caching Strategy)

**The Problem:** Without caching, macro execution on every keystroke = death.

```
âŒ NAIVE APPROACH (Haxe-style, 800ms per completion)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Keystroke â†’ Parse â†’ Expand ALL macros â†’ TypeCheck â†’ Completion
                         â”‚
                         â””â”€â”€ Network I/O, VM execution, full AST walk
                             EVERY. SINGLE. TIME.

âœ… TRANS-AM APPROACH (Rust-analyzer style, <50ms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Keystroke â†’ Parse â†’ Query Cache â†’ HIT? â†’ Return instantly
                         â”‚
                         â””â”€â”€ MISS? â†’ Expand â†’ Cache â†’ Return
                                       â”‚
                                       â””â”€â”€ Background: pre-warm related
```

### Cache Key Design (Content-Addressed)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           MACRO EXPANSION CACHE KEY                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  cache_key = hash(                                                          â”‚
â”‚      macro_source_hash,     // derive.ms content â†’ changes rarely           â”‚
â”‚      target_ast_hash,       // class User { ... } â†’ changes on edit         â”‚
â”‚      arguments_hash,        // ["Eq", "Hash"] â†’ changes rarely              â”‚
â”‚      dependencies_hash,     // imports in derive.ms â†’ changes rarely        â”‚
â”‚  )                                                                          â”‚
â”‚                                                                             â”‚
â”‚  EXAMPLE:                                                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                  â”‚
â”‚  @derive(Eq, Hash)          macro_source:  0xA3F5...  (std/macros/derive.ms)â”‚
â”‚  class User {               target_ast:    0x7B2C...  (hash of class AST)   â”‚
â”‚      name: string;          arguments:     0x1D4E...  (["Eq", "Hash"])      â”‚
â”‚      age: number;           dependencies:  0x0000...  (none)                â”‚
â”‚  }                          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚                             CACHE KEY:     0x8F3A2B1C...                    â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Invalidation Strategy (Minimal Re-expansion)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SMART INVALIDATION                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  WHAT CHANGED?                    â”‚  WHAT INVALIDATES?                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚                                   â”‚                                         â”‚
â”‚  User edits class body:           â”‚  Only THIS class's expansion            â”‚
â”‚  class User { age: string; }      â”‚  (1 cache entry)                        â”‚
â”‚                      ^^^^^^       â”‚                                         â”‚
â”‚                                   â”‚                                         â”‚
â”‚  User edits macro args:           â”‚  Only THIS class's expansion            â”‚
â”‚  @derive(Eq)  â†’  @derive(Hash)    â”‚  (1 cache entry)                        â”‚
â”‚           ^^              ^^^^    â”‚                                         â”‚
â”‚                                   â”‚                                         â”‚
â”‚  Macro source changes:            â”‚  ALL expansions using this macro        â”‚
â”‚  std/macros/derive.ms edited      â”‚  (N cache entries - rare event!)        â”‚
â”‚                                   â”‚                                         â”‚
â”‚  Nothing changed:                 â”‚  NOTHING invalidates                    â”‚
â”‚  User just moves cursor           â”‚  (0 cache entries - instant response!)  â”‚
â”‚                                   â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Five-Level Caching Hierarchy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      TRANS-AM CACHE HIERARCHY                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  LEVEL 1: Bytecode Cache (Disk)                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                            â”‚
â”‚  Location: .metascript-cache/macros/<hash>.hbc                              â”‚
â”‚  Contents: Compiled Hermes bytecode for each macro                          â”‚
â”‚  Lifetime: Persists across sessions                                         â”‚
â”‚  Benefit:  Skip JSâ†’bytecode compilation (45ms â†’ 0.2ms)                      â”‚
â”‚                                                                             â”‚
â”‚  LEVEL 2: Macro Output Cache (Memory, Content-Addressed)                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚  Location: TransAmDatabase.macro_output_cache                               â”‚
â”‚  Contents: Expanded AST nodes keyed by input hash                           â”‚
â”‚  Lifetime: Current session                                                  â”‚
â”‚  Benefit:  Skip VM execution entirely on cache hit                          â”‚
â”‚                                                                             â”‚
â”‚  LEVEL 3: Type-Checked AST Cache (Memory)                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
â”‚  Location: TransAmDatabase.type_cache                                       â”‚
â”‚  Contents: Type annotations on expanded AST                                 â”‚
â”‚  Lifetime: Until source changes                                             â”‚
â”‚  Benefit:  Skip type inference on repeated queries                          â”‚
â”‚                                                                             â”‚
â”‚  LEVEL 4: Completion Cache (Memory, LRU)                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
â”‚  Location: LSPServer.completion_cache                                       â”‚
â”‚  Contents: Pre-computed completion lists per location                       â”‚
â”‚  Lifetime: Until cursor moves significantly                                 â”‚
â”‚  Benefit:  Skip member enumeration on repeated completions                  â”‚
â”‚                                                                             â”‚
â”‚  LEVEL 5: Network Response Cache (Disk, TTL)                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                â”‚
â”‚  Location: .metascript-cache/network/<url-hash>.json                        â”‚
â”‚  Contents: Responses from @comptime fetch() calls                           â”‚
â”‚  Lifetime: Configurable TTL (default: 1 hour)                               â”‚
â”‚  Benefit:  Skip network I/O on repeated builds                              â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Timeout Bailout (No Configuration Needed)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TIMEOUT-BASED BAILOUT                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  PHILOSOPHY: No user configuration. 5 levels always. Slow macros get        â”‚
â”‚  warned, not cached. Users fix their macros, not tune cache settings.       â”‚
â”‚                                                                             â”‚
â”‚  RESEARCH: Production systems (rust-analyzer, nimsuggest, haxe-lsp)         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  rust-analyzer: 2s proc-macro timeout, 2000 LRU, >100ms = "slow"            â”‚
â”‚  nimsuggest:    5s timeout, 500 mem + 10K disk cache                        â”‚
â”‚  haxe-lsp:      1s timeout, SQLite disk cache, 24h TTL                      â”‚
â”‚                                                                             â”‚
â”‚  METASCRIPT TIMEOUTS (based on research):                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
â”‚  Macro execution (L2):     100ms  â”‚ Flag as slow, return fallback           â”‚
â”‚  Type checking (L3):       200ms  â”‚ Flag as slow, return fallback           â”‚
â”‚  Completion compute (L4):   50ms  â”‚ Return partial results                  â”‚
â”‚  Network fetch (L5):       2000ms â”‚ Cache result, warn if slow              â”‚
â”‚                                                                             â”‚
â”‚  WHAT HAPPENS ON TIMEOUT:                                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚  1. Operation completes but is flagged as "slow"                            â”‚
â”‚  2. Result is NOT cached (would slow down future requests)                  â”‚
â”‚  3. Warning emitted to user:                                                â”‚
â”‚     "Macro @derive(Serialize) on class BigClass took 250ms (limit: 100ms)  â”‚
â”‚      This macro is excluded from LSP caching. Consider optimizing."         â”‚
â”‚  4. Subsequent LSP requests: return fallback immediately, schedule          â”‚
â”‚     background revalidation (stale-while-revalidate pattern)                â”‚
â”‚  5. Full compile: still runs all macros (correctness > speed)               â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementation Pattern (rust-analyzer style)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COOPERATIVE CANCELLATION + SLOW TRACKING                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  KEY INSIGHT from rust-analyzer: Use cooperative cancellation via           â”‚
â”‚  Salsa's `unwind_if_cancelled()` pattern. Long-running queries              â”‚
â”‚  periodically check if they should abort.                                   â”‚
â”‚                                                                             â”‚
â”‚  // Trans-Am database with cancellation support                             â”‚
â”‚  pub const TransAmDatabase = struct {                                       â”‚
â”‚      cancellation_version: std.atomic.Value(u64),                           â”‚
â”‚      slow_queries: std.AutoHashMap(u64, SlowQueryInfo),                     â”‚
â”‚      macro_cache: LruCache(2000, u64, *ast.Node),  // rust-analyzer default â”‚
â”‚                                                                             â”‚
â”‚      // Called periodically by long-running queries                         â”‚
â”‚      pub fn unwindIfCancelled(self: *@This()) !void {                       â”‚
â”‚          if (self.current_version != self.cancellation_version.load(.seq_cst)) {â”‚
â”‚              return error.QueryCancelled;                                   â”‚
â”‚          }                                                                  â”‚
â”‚      }                                                                      â”‚
â”‚                                                                             â”‚
â”‚      // Called when user types (didChange notification)                     â”‚
â”‚      pub fn cancelPendingQueries(self: *@This()) void {                     â”‚
â”‚          _ = self.cancellation_version.fetchAdd(1, .seq_cst);               â”‚
â”‚      }                                                                      â”‚
â”‚  };                                                                         â”‚
â”‚                                                                             â”‚
â”‚  // Macro expansion with timeout + slow tracking                            â”‚
â”‚  pub fn expandMacroForLSP(self: *@This(), node: *ast.Node) !?ExpandResult { â”‚
â”‚      const key = computeMacroKey(node);                                     â”‚
â”‚                                                                             â”‚
â”‚      // 1. Check if known slow - return fallback immediately                â”‚
â”‚      if (self.slow_queries.get(key)) |info| {                               â”‚
â”‚          self.scheduleBackgroundRevalidation(key);  // stale-while-revalidateâ”‚
â”‚          return .{ .ast = null, .stale = true };                            â”‚
â”‚      }                                                                      â”‚
â”‚                                                                             â”‚
â”‚      // 2. Check cache                                                      â”‚
â”‚      if (self.macro_cache.get(key)) |cached| {                              â”‚
â”‚          return .{ .ast = cached, .stale = false };                         â”‚
â”‚      }                                                                      â”‚
â”‚                                                                             â”‚
â”‚      // 3. Execute with timeout tracking                                    â”‚
â”‚      const start = std.time.milliTimestamp();                               â”‚
â”‚      const result = self.expandMacro(node) catch |err| {                    â”‚
â”‚          if (err == error.QueryCancelled) return null;  // User typed       â”‚
â”‚          return err;                                                        â”‚
â”‚      };                                                                     â”‚
â”‚      const elapsed = std.time.milliTimestamp() - start;                     â”‚
â”‚                                                                             â”‚
â”‚      // 4. Track slow queries (>100ms threshold from rust-analyzer)         â”‚
â”‚      if (elapsed > 100) {                                                   â”‚
â”‚          self.slow_queries.put(key, .{                                      â”‚
â”‚              .last_duration = elapsed,                                      â”‚
â”‚              .hit_count = 1,                                                â”‚
â”‚          });                                                                â”‚
â”‚          self.emitSlowMacroWarning(node, elapsed);                          â”‚
â”‚          return .{ .ast = result, .stale = false, .slow = true };           â”‚
â”‚      }                                                                      â”‚
â”‚                                                                             â”‚
â”‚      // 5. Cache fast results                                               â”‚
â”‚      self.macro_cache.put(key, result);                                     â”‚
â”‚      return .{ .ast = result, .stale = false, .slow = false };              â”‚
â”‚  }                                                                          â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### LRU Cache with Fixed Size (rust-analyzer pattern)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LRU CACHE IMPLEMENTATION                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  // Based on rust-analyzer's 2000-entry default                             â”‚
â”‚  pub fn LruCache(comptime max_size: usize, K: type, V: type) type {         â”‚
â”‚      return struct {                                                        â”‚
â”‚          entries: std.AutoArrayHashMap(K, Entry),                           â”‚
â”‚          order: std.DoublyLinkedList(K),                                    â”‚
â”‚          allocator: std.mem.Allocator,                                      â”‚
â”‚                                                                             â”‚
â”‚          const Entry = struct { value: V, node: *OrderNode };               â”‚
â”‚          const OrderNode = std.DoublyLinkedList(K).Node;                    â”‚
â”‚                                                                             â”‚
â”‚          pub fn get(self: *@This(), key: K) ?V {                            â”‚
â”‚              if (self.entries.get(key)) |entry| {                           â”‚
â”‚                  // Move to front (most recently used)                      â”‚
â”‚                  self.order.remove(entry.node);                             â”‚
â”‚                  self.order.prepend(entry.node);                            â”‚
â”‚                  return entry.value;                                        â”‚
â”‚              }                                                              â”‚
â”‚              return null;                                                   â”‚
â”‚          }                                                                  â”‚
â”‚                                                                             â”‚
â”‚          pub fn put(self: *@This(), key: K, value: V) void {                â”‚
â”‚              // Evict oldest if at capacity                                 â”‚
â”‚              if (self.entries.count() >= max_size) {                        â”‚
â”‚                  if (self.order.popBack()) |oldest| {                       â”‚
â”‚                      _ = self.entries.remove(oldest.data);                  â”‚
â”‚                      self.allocator.destroy(oldest);                        â”‚
â”‚                  }                                                          â”‚
â”‚              }                                                              â”‚
â”‚              // Insert new entry at front                                   â”‚
â”‚              const node = self.allocator.create(OrderNode);                 â”‚
â”‚              node.data = key;                                               â”‚
â”‚              self.order.prepend(node);                                      â”‚
â”‚              self.entries.put(key, .{ .value = value, .node = node });      â”‚
â”‚          }                                                                  â”‚
â”‚      };                                                                     â”‚
â”‚  }                                                                          â”‚
â”‚                                                                             â”‚
â”‚  // Usage in Trans-Am                                                       â”‚
â”‚  const MacroCache = LruCache(2000, u64, *ast.Node);    // L2: macro output  â”‚
â”‚  const TypeCache = LruCache(2000, u64, *TypeInfo);    // L3: type info     â”‚
â”‚  const CompletionCache = LruCache(500, u64, []Item);  // L4: completions   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Safety Constraints (Automatic)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CACHE SAFETY (BUILT-IN, NOT CONFIGURABLE)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  RULE 1: LRU eviction (rust-analyzer defaults)                              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                              â”‚
â”‚  L2 Macro cache:     2000 entries (~50MB)                                   â”‚
â”‚  L3 Type cache:      2000 entries (~50MB)                                   â”‚
â”‚  L4 Completion cache: 500 entries (~20MB)                                   â”‚
â”‚  Total bounded: ~150MB max. No OOM. No config needed.                       â”‚
â”‚                                                                             â”‚
â”‚  RULE 2: Cooperative cancellation (Salsa pattern)                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
â”‚  User types â†’ increment cancellation_version â†’ all pending queries abort    â”‚
â”‚  Long queries call unwindIfCancelled() periodically                         â”‚
â”‚  No wasted work on outdated requests                                        â”‚
â”‚                                                                             â”‚
â”‚  RULE 3: NEVER serve stale diagnostics                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  Stale-while-revalidate for completions/hover only.                         â”‚
â”‚  Diagnostics ALWAYS computed fresh (correctness > latency).                 â”‚
â”‚                                                                             â”‚
â”‚  RULE 4: Slow query tracking (>100ms = slow, from rust-analyzer)            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            â”‚
â”‚  First time: Execute, measure, flag if slow                                 â”‚
â”‚  Subsequent: Return fallback immediately + background revalidate            â”‚
â”‚  User gets warning: "Consider optimizing this macro"                        â”‚
â”‚                                                                             â”‚
â”‚  RULE 5: Content-addressed cache keys (rust-analyzer pattern)               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
â”‚  cache_key = hash(                                                          â”‚
â”‚      module_id,           // Which module contains macro call               â”‚
â”‚      macro_name,          // @derive, @comptime, etc.                       â”‚
â”‚      input_ast_hash,      // Hash of target class/function AST              â”‚
â”‚      arguments_hash,      // ["Eq", "Hash"] â†’ hash                          â”‚
â”‚      env_vars_hash,       // Tracked env vars used by macro                 â”‚
â”‚      file_deps_hash,      // Files read by macro                            â”‚
â”‚  )                                                                          â”‚
â”‚  Change ANY input â†’ cache miss â†’ re-expand                                  â”‚
â”‚                                                                             â”‚
â”‚  RESULT: Self-optimizing system. Zero configuration.                        â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Request Flow with Caching

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   COMPLETION REQUEST FLOW                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  user.â–ˆ  (completion request)                                               â”‚
â”‚     â”‚                                                                       â”‚
â”‚     â–¼                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ L4: Completion Cache                                            â”‚       â”‚
â”‚  â”‚ Key: (file, line, col, prefix)                                  â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                â”‚                                                            â”‚
â”‚       HIT â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€ MISS                                                  â”‚
â”‚        â”‚       â”‚        â”‚                                                   â”‚
â”‚        â”‚       â”‚        â–¼                                                   â”‚
â”‚        â”‚       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚        â”‚       â”‚  â”‚ L3: Type Cache                                  â”‚      â”‚
â”‚        â”‚       â”‚  â”‚ Key: (file_hash, expanded_ast_hash)             â”‚      â”‚
â”‚        â”‚       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚        â”‚       â”‚                â”‚                                           â”‚
â”‚        â”‚       â”‚       HIT â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€ MISS                                 â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚                                  â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â–¼                                  â”‚
â”‚        â”‚       â”‚        â”‚       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚        â”‚       â”‚        â”‚       â”‚  â”‚ L2: Macro Output Cache          â”‚     â”‚
â”‚        â”‚       â”‚        â”‚       â”‚  â”‚ Key: hash(macro, target, args)  â”‚     â”‚
â”‚        â”‚       â”‚        â”‚       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚        â”‚       â”‚        â”‚       â”‚                â”‚                          â”‚
â”‚        â”‚       â”‚        â”‚       â”‚       HIT â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€ MISS                â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚        â”‚                 â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚        â–¼                 â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚  â”‚ L1: Bytecode    â”‚    â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚  â”‚ + Hermes VM     â”‚    â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚  â”‚ EXECUTE MACRO   â”‚    â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚           â”‚             â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚           â–¼             â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚     Store in L2         â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â”‚       â”‚           â”‚             â”‚
â”‚        â”‚       â”‚        â”‚       â”‚        â—€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚        â”‚       â”‚        â”‚       â”‚                                          â”‚
â”‚        â”‚       â”‚        â”‚       â–¼                                          â”‚
â”‚        â”‚       â”‚        â”‚  TypeCheck expanded AST                          â”‚
â”‚        â”‚       â”‚        â”‚       â”‚                                          â”‚
â”‚        â”‚       â”‚        â”‚       â–¼                                          â”‚
â”‚        â”‚       â”‚        â”‚  Store in L3                                     â”‚
â”‚        â”‚       â”‚        â”‚       â”‚                                          â”‚
â”‚        â”‚       â”‚        â—€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚        â”‚       â”‚                                                           â”‚
â”‚        â”‚       â–¼                                                           â”‚
â”‚        â”‚  Enumerate members from typed AST                                 â”‚
â”‚        â”‚       â”‚                                                           â”‚
â”‚        â”‚       â–¼                                                           â”‚
â”‚        â”‚  Store in L4                                                      â”‚
â”‚        â”‚       â”‚                                                           â”‚
â”‚        â—€â”€â”€â”€â”€â”€â”€â”€â”˜                                                           â”‚
â”‚        â”‚                                                                   â”‚
â”‚        â–¼                                                                   â”‚
â”‚  RETURN COMPLETIONS (<50ms with caching!)                                  â”‚
â”‚                                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Background Pre-warming Strategy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      PROACTIVE CACHE WARMING                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  TRIGGER                          â”‚  ACTION                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚                                   â”‚                                         â”‚
â”‚  File opened in editor            â”‚  Background: expand all macros in file  â”‚
â”‚                                   â”‚  Priority: visible viewport first       â”‚
â”‚                                   â”‚                                         â”‚
â”‚  File saved                       â”‚  Background: re-expand changed macros   â”‚
â”‚                                   â”‚  Priority: edited functions first       â”‚
â”‚                                   â”‚                                         â”‚
â”‚  Import added                     â”‚  Background: expand macros in import    â”‚
â”‚                                   â”‚  Priority: low (not visible yet)        â”‚
â”‚                                   â”‚                                         â”‚
â”‚  Cursor enters macro scope        â”‚  Background: pre-compute completions    â”‚
â”‚                                   â”‚  Priority: high (user about to type)    â”‚
â”‚                                   â”‚                                         â”‚
â”‚  Idle for 500ms                   â”‚  Background: warm related files         â”‚
â”‚                                   â”‚  Priority: files in same directory      â”‚
â”‚                                   â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Stale-While-Revalidate Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    STALE-WHILE-REVALIDATE                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  SCENARIO: User edits class, immediately requests completion                â”‚
â”‚                                                                             â”‚
â”‚  âŒ BLOCKING APPROACH:                                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                     â”‚
â”‚  Edit â†’ Wait for re-expand (50ms) â†’ Wait for typecheck (20ms) â†’ Return     â”‚
â”‚         User perceives 70ms lag = noticeable!                               â”‚
â”‚                                                                             â”‚
â”‚  âœ… STALE-WHILE-REVALIDATE:                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â”‚
â”‚  Edit â†’ Return STALE (0ms) â†’ Background: re-expand â†’ Update when ready     â”‚
â”‚         User sees instant response!                                         â”‚
â”‚         Stale data is 99% correct (only missing new field)                  â”‚
â”‚         Fresh data arrives in ~70ms, UI updates silently                    â”‚
â”‚                                                                             â”‚
â”‚  IMPLEMENTATION:                                                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                            â”‚
â”‚  pub fn getExpanded(key: CacheKey) -> (ast: *Node, fresh: bool) {           â”‚
â”‚      if (cache.get(key)) |entry| {                                          â”‚
â”‚          if (entry.isValid()) {                                             â”‚
â”‚              return (entry.ast, true);  // Fresh hit                        â”‚
â”‚          } else {                                                           â”‚
â”‚              spawn revalidateInBackground(key);                             â”‚
â”‚              return (entry.ast, false); // Stale, revalidating              â”‚
â”‚          }                                                                  â”‚
â”‚      }                                                                      â”‚
â”‚      // True miss - must compute synchronously                              â”‚
â”‚      return (expand(key), true);                                            â”‚
â”‚  }                                                                          â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementation Status

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CACHE IMPLEMENTATION STATUS                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  CACHE LEVELS:                                                              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                              â”‚
â”‚  LEVEL â”‚ STATUS     â”‚ SIZE    â”‚ LOCATION                  â”‚ NOTES          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  L1    â”‚ âœ… Done    â”‚ Disk    â”‚ .metascript-cache/macros/ â”‚ Hermes bytecodeâ”‚
â”‚  L2    â”‚ âœ… Done    â”‚ 2000    â”‚ TransAmDatabase           â”‚ LRU bounded    â”‚
â”‚  L3    â”‚ âœ… Done    â”‚ 2000    â”‚ TransAmDatabase.type_cacheâ”‚ + symbols_cacheâ”‚
â”‚  L4    â”‚ âœ… Done    â”‚ 500     â”‚ TransAmDatabase           â”‚ CompletionCacheâ”‚
â”‚  L5    â”‚ âœ… Done    â”‚ Disk    â”‚ .metascript-cache/network/â”‚ NetworkCache   â”‚
â”‚                                                                             â”‚
â”‚  RUST-ANALYZER PATTERNS IMPLEMENTED:                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  Feature                    â”‚ Status   â”‚ Priority â”‚ Reference              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  LRU cache (2000 entries)   â”‚ âœ… Done  â”‚ P0       â”‚ rust-analyzer default  â”‚
â”‚  Cooperative cancellation   â”‚ âœ… Done  â”‚ P0       â”‚ Salsa unwind_if_cancel â”‚
â”‚  Slow query tracking >100ms â”‚ âœ… Done  â”‚ P0       â”‚ rust-analyzer pattern  â”‚
â”‚  Content-addressed keys     â”‚ âœ… Done  â”‚ P0       â”‚ MacroOutputCache       â”‚
â”‚  Freshness tracking         â”‚ âœ… Done  â”‚ P0       â”‚ FreshnessLRUCache      â”‚
â”‚  Never stale diagnostics    â”‚ âœ… Done  â”‚ P0       â”‚ File hash validation   â”‚
â”‚  Stale-while-revalidate     â”‚ âœ… Done  â”‚ P1       â”‚ FreshnessLRUCache      â”‚
â”‚  Background job queue       â”‚ âœ… Done  â”‚ P1       â”‚ BackgroundWorker       â”‚
â”‚  Completion cache (L4)      â”‚ âœ… Done  â”‚ P1       â”‚ CompletionCache        â”‚
â”‚  Network cache (L5)         â”‚ âœ… Done  â”‚ P2       â”‚ NetworkCache (disk)    â”‚
â”‚  Macro timeout (5s)         â”‚ âœ… Done  â”‚ P0       â”‚ MACRO_TIMEOUT_MS       â”‚
â”‚  Eviction callbacks         â”‚ âœ… Done  â”‚ P0       â”‚ Memory leak prevention â”‚
â”‚  Type checker caching       â”‚ âœ… Done  â”‚ P1       â”‚ db.checkFile()         â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Actual Data Flow (December 2024)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TRANS-AM CACHE DATA FLOW                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  INPUT LAYER (never cached, set by LSP)                                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                     â”‚
â”‚    file_texts: StringHashMap    â† setFileText() from didChange              â”‚
â”‚    file_hashes: StringHashMap   â† content hash for change detection         â”‚
â”‚                                                                             â”‚
â”‚  SYNTAX LAYER (L1 - lexer-based, fast)                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚    parse_cache: LRUCache(128)   â† ParseResult (AST + errors)                â”‚
â”‚    syntax_token_cache           â† SyntaxToken[] for highlighting            â”‚
â”‚                                                                             â”‚
â”‚  SEMANTIC LAYER (L2/L3 - depends on L1)                                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚    macro_cache: LRUCache(512)   â† MacroExpansion (expanded AST)             â”‚
â”‚    macro_output_cache           â† Content-addressed (inputâ†’output hash)     â”‚
â”‚    symbols_cache                â† CachedSymbolTable (TypeChecker)           â”‚
â”‚    type_cache: LRUCache(2000)   â† TypeInference results                     â”‚
â”‚                                                                             â”‚
â”‚  FEATURE LAYER (L4 - depends on L2/L3)                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚    completion_cache             â† CompletionItem[] per file                 â”‚
â”‚    diagnostics_cache            â† Diagnostic[] per file                     â”‚
â”‚                                                                             â”‚
â”‚  PERSISTENT LAYER (L5 - disk, survives restarts)                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
â”‚    bytecode_cache (disk)        â† .metascript-cache/macros/*.hbc            â”‚
â”‚    network_cache (disk)         â† .metascript-cache/network/*.json          â”‚
â”‚                                                                             â”‚
â”‚  INVALIDATION FLOW:                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                         â”‚
â”‚    didChange â†’ setFileText() â†’ increment revision                           â”‚
â”‚                             â†’ invalidate parse_cache                        â”‚
â”‚                             â†’ invalidate symbols_cache                      â”‚
â”‚                             â†’ mark query_cache RED                          â”‚
â”‚                             â†’ invalidate completion_cache                   â”‚
â”‚                                                                             â”‚
â”‚  CANCELLATION FLOW:                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                         â”‚
â”‚    didChange â†’ cancelPendingQueries()                                       â”‚
â”‚             â†’ increment cancellation_version                                â”‚
â”‚             â†’ all in-flight queries check & abort                           â”‚
â”‚             â†’ 16+ checkpoints in hot paths                                  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Performance Guarantees

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      PERFORMANCE TARGETS                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  OPERATION              â”‚ L4 HIT  â”‚ L3 HIT  â”‚ L2 HIT  â”‚ COLD    â”‚ MAX      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  Completion             â”‚ <5ms    â”‚ <20ms   â”‚ <50ms   â”‚ <200ms  â”‚ 500ms    â”‚
â”‚  Hover                  â”‚ <5ms    â”‚ <15ms   â”‚ <30ms   â”‚ <100ms  â”‚ 200ms    â”‚
â”‚  Go-to-definition       â”‚ <5ms    â”‚ <10ms   â”‚ <20ms   â”‚ <50ms   â”‚ 100ms    â”‚
â”‚  Diagnostics (file)     â”‚ N/A     â”‚ <50ms   â”‚ <200ms  â”‚ <500ms  â”‚ 1s       â”‚
â”‚  Diagnostics (project)  â”‚ N/A     â”‚ <200ms  â”‚ <1s     â”‚ <5s     â”‚ 10s      â”‚
â”‚                                                                             â”‚
â”‚  CACHE HIT RATES (Expected):                                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â”‚
â”‚  L4 (Completion):  80% (cursor often in same area)                          â”‚
â”‚  L3 (Types):       95% (types stable between edits)                         â”‚
â”‚  L2 (Macro):       99% (macros rarely change)                               â”‚
â”‚  L1 (Bytecode):    99.9% (macro source almost never changes)                â”‚
â”‚                                                                             â”‚
â”‚  RESULT: 99%+ of requests served in <20ms!                                  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Network I/O Caching (@comptime fetch)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   NETWORK CACHE FOR @COMPTIME                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  const api = @comptime {                                                    â”‚
â”‚      const schema = fetch("https://api.example.com/openapi.json");          â”‚
â”‚      return generateClient(schema);                                         â”‚
â”‚  };                                                                         â”‚
â”‚                                                                             â”‚
â”‚  FIRST RUN:                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                 â”‚
â”‚  1. Hermes executes fetch() â†’ actual network request (500ms)                â”‚
â”‚  2. Response cached: .metascript-cache/network/0xA3F5.json                  â”‚
â”‚  3. Generated AST cached in L2                                              â”‚
â”‚  4. Total: 600ms (acceptable for first compile)                             â”‚
â”‚                                                                             â”‚
â”‚  SUBSEQUENT RUNS:                                                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                          â”‚
â”‚  1. Check L2 (macro output) â†’ HIT â†’ return instantly                        â”‚
â”‚  2. Never even check network cache                                          â”‚
â”‚  3. Total: <1ms                                                             â”‚
â”‚                                                                             â”‚
â”‚  CACHE INVALIDATION:                                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                       â”‚
â”‚  â€¢ TTL-based: default 1 hour, configurable per-macro                        â”‚
â”‚  â€¢ Manual: msc cache clear --network                                        â”‚
â”‚  â€¢ Version bump: changing macro source invalidates                          â”‚
â”‚                                                                             â”‚
â”‚  @comptime({ cache: { ttl: "24h", key: "api-schema-v2" } })                 â”‚
â”‚  function fetchSchema() {                                                   â”‚
â”‚      return fetch("https://api.example.com/openapi.json");                  â”‚
â”‚  }                                                                          â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Critical Design Principles

**1. LSP-First Architecture**
- Design LSP as primary interface, not afterthought
- Compiler serves LSP queries
- Incremental compilation from day one
- **LSP queries EXPANDED AST, not source AST**

**2. Caching is Non-Negotiable**
- Cache macro expansion by AST fingerprint
- Invalidate only when macro source/inputs change
- Query-based system (Salsa or equivalent)

**3. Lazy Macro Expansion**
- Do NOT expand on every keystroke
- Expand on-demand or on-save only
- Never block user input

**4. Separate Static from Dynamic**
- Static: TypeScript + `@derive/@comptime` (Tree-sitter)
- Dynamic: Macro expansion + type checking (LSP server)

**5. Incremental Everything**
- Re-parse only changed functions
- Re-expand only affected macros
- Re-check only modified scopes

---

## Performance Targets

| Feature | Target | Max |
|---------|--------|-----|
| Syntax highlighting | <16ms | 50ms |
| Hover (static) | <50ms | 100ms |
| Completion (no macros) | <100ms | 200ms |
| Completion (with macros) | <200ms | 500ms |
| Macro expansion preview | <500ms | 1s |
| Full diagnostics | <1s | 2s |

**Rule:** If users notice lag, it's too slow.

---

## Three-Layer Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Editor (VSCode/Neovim)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Tree-sitter    â”‚  Metascript LSP       â”‚
â”‚ (Static)       â”‚  (Semantic)           â”‚
â”‚                â”‚                        â”‚
â”‚ Highlighting   â”‚  Salsa Query Cache    â”‚
â”‚ (<16ms)        â”‚  â”œâ”€ Macro (Cached)    â”‚
â”‚                â”‚  â”œâ”€ Type (Incremental)â”‚
â”‚                â”‚  â””â”€ Diagnostics       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
          msc compiler
      (explicit request only)
```

---

## Implementation Core

### LSP Server (Zig)

```zig
pub const LSPServer = struct {
    macro_cache: std.AutoHashMap(u64, *ast.Node),

    pub fn onDidChange(self: *LSPServer, params: DidChangeParams) !void {
        doc.ast = try parser.parse(self.arena, doc.text);
        doc.expanded_ast = try self.expandWithCache(doc.ast.?);
        const errors = try checker.checkIncremental(doc.expanded_ast.?);
        try self.publishDiagnostics(params.uri);
    }

    fn expandWithCache(self: *LSPServer, node: *ast.Node) !*ast.Node {
        const hash = computeASTHash(node);
        if (self.macro_cache.get(hash)) |cached| return cached;

        const expanded = try macro.expand(self.arena, node);
        try self.macro_cache.put(hash, expanded);
        return expanded;
    }
};
```

### Incremental Expansion

```zig
pub fn incrementalExpand(self: *LSPServer, doc: *Document, change: TextChange) !void {
    const affected = try findMacrosInRange(doc.ast.?, change.range);

    for (affected) |m| {
        _ = self.macro_cache.remove(computeASTHash(m));
        const expanded = try macro.expandSingle(self.arena, m);
        try self.macro_cache.put(computeASTHash(m), expanded);
    }

    try checker.checkIncremental(doc.expanded_ast.?, affected);
}
```

### Macro Expansion Preview

```typescript
// VSCode: Show expansion side-by-side
vscode.commands.registerCommand('metascript.showMacroExpansion', async (code: string) => {
    const doc = await vscode.workspace.openTextDocument({ content: code });
    await vscode.window.showTextDocument(doc, vscode.ViewColumn.Beside);
});
```

---

## Critical Anti-Patterns

**âŒ Full compiler per LSP request** (Nim: 5-6s)
âœ… Separate LSP analysis engine

**âŒ Re-expand macros every keystroke** (Haxe: 800ms)
âœ… Expand on-save or on-demand

**âŒ Tight LSP-compiler coupling** (Nim/Haxe)
âœ… Custom query engine

**âŒ Ignore memory leaks** (Nim: 24GB)
âœ… Stateless expansion + GC

**âŒ Block for semantic analysis** (Nim: 100% CPU)
âœ… Async background + serve stale

---

## Implementation Roadmap

### Phase 1: LRU Cache Infrastructure (P0) âœ… COMPLETE

**Goal:** Bounded memory, no OOM, rust-analyzer defaults

```
DONE 1.1: LruCache generic data structure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/cache.zig (LRUCache type)

[x] LRUCache(V) with configurable capacity
[x] O(1) get with access order update
[x] O(1) put with LRU eviction when full
[x] Unit tests: insert, evict, get updates order

DONE 1.2: Integrated LRU into Trans-Am macro cache
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/cache.zig, src/transam/transam.zig

[x] MacroOutputCache uses LRUCache(2000) - DEFAULT_MACRO_CACHE_CAPACITY
[x] Cache stats: hits, misses, evictions, slow_queries_flagged
[x] Test: cache evicts oldest after capacity reached
[x] Memory bounded (~50MB for macro cache)

DONE 1.3: Added LRU to type cache (L3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/transam.zig

[x] type_cache: LRUCache(TypeInference) with 2000 entries
[x] Eviction on capacity, not on every query
```

### Phase 2: Cooperative Cancellation (P0) âœ… COMPLETE

**Goal:** User types â†’ outdated queries abort immediately

```
DONE 2.1: Cancellation infrastructure in Trans-Am
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/transam.zig

[x] cancellation_version: std.atomic.Value(u64)
[x] cancel_flag: std.atomic.Value(bool) (legacy)
[x] cancelPendingQueries() - increments version + sets flag
[x] unwindIfCancelled(starting_version) - returns error.QueryCancelled
[x] resetAfterCancellation() - clears flag
[x] getCancellationVersion() - for Salsa-style queries

DONE 2.2: Wired cancellation to LSP didChange
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/lsp/server.zig

[x] handleDidChange calls db.cancelPendingQueries() at start
[x] runDiagnostics calls db.resetAfterCancellation() after completion
[x] All pending queries abort via checkCancellation()

DONE 2.3: Cancellation checkpoints in long queries
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/transam.zig

[x] parse(): checkCancellation() at entry
[x] macroArg(): checkCancellation() at entry
[x] macroExpand(): checkCancellation() at entry
[x] getDiagnostics(): checkCancellation() at entry
```

### Phase 3: Slow Query Tracking (P0) âœ… COMPLETE

**Goal:** >100ms macros warned + excluded from LSP cache

```
DONE 3.1: Slow query tracking structure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/cache.zig

[x] slow_queries: std.AutoHashMap(u64, SlowQueryInfo)
[x] SlowQueryInfo = { last_duration_ms, hit_count, first_seen_ms }
[x] SLOW_QUERY_THRESHOLD_MS = 100 (rust-analyzer default)

DONE 3.2: Measure and track query duration
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/transam.zig

[x] macroExpand() wraps execution with timing
[x] If elapsed > 100ms: markSlow(call_hash, elapsed_ms)
[x] Stats track slow_queries_flagged count

DONE 3.3: Skip known-slow queries on subsequent requests
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/transam.zig

[x] Before expansion: isSlowQuery(call_hash) check
[x] If slow: return error.SlowMacroSkipped
[x] Stats track slow_queries_skipped count
[ ] TODO: Schedule background revalidation (Phase 5)
```

### Phase 4: Stale Diagnostics Guard (P0) âœ… COMPLETE

**Goal:** Diagnostics ALWAYS fresh, completions can be stale

```
DONE 4.1: Freshness infrastructure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/cache.zig

[x] FreshnessLRUCache(V) - LRU with freshness tracking
[x] getAllowStale() - returns cached even if stale (for completions)
[x] getFreshOnly() - returns null if stale (for diagnostics)
[x] markStale(key) - mark specific entry stale
[x] invalidateAll() - mark all entries stale on file change
[x] Unit tests: fresh/stale behavior verified

DONE 4.2: Diagnostics already guaranteed fresh
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/transam.zig

[x] getDiagnostics() validates file_hash before returning cache
[x] Cache miss or hash mismatch â†’ regenerate (always fresh)
[x] Diagnostics never return stale data

LSP Method Staleness Policy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
| Method                    | Allow Stale? | Reason                    |
|---------------------------|--------------|---------------------------|
| textDocument/diagnostic   | NO           | User sees errors          |
| textDocument/completion   | YES          | Latency critical          |
| textDocument/hover        | YES          | Latency critical          |
| textDocument/definition   | YES          | User can retry            |
| textDocument/references   | YES          | User can retry            |
| textDocument/formatting   | NO           | Must be accurate          |
```

### Phase 5: Background Revalidation (P1) âœ… COMPLETE

**Goal:** Stale-while-revalidate pattern for responsiveness

```
DONE 5.1: Background worker infrastructure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/lsp/background_worker.zig (NEW FILE)

[x] BackgroundWorker with priority job queue
[x] Priority levels: visible > imported > open > background
[x] Job types: macro_expand, type_check, prewarm, completion_refresh
[x] Cancellation-aware (checks version before processing)
[x] queue(), popNext(), processAll(), cancelAll()
[x] Unit tests: priority ordering, stale job skipping

DONE 5.2: Wire to LSP server
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/lsp/server.zig

[x] BackgroundWorker instantiated in Server struct
[x] Initialized in initTransAm() with Trans-Am cancellation_version
[x] Pre-warming on file open (handleDidOpen queues .prewarm job)
[x] Stale completion triggers .completion_refresh job
[x] Cleaned up in deinit()
```

### Phase 6: Completion Cache L4 (P1) âœ… COMPLETE

**Goal:** Skip member enumeration on repeated completions

```
DONE 6.1: Completion cache infrastructure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/cache.zig

[x] CompletionCache with FreshnessLRUCache (500 entries)
[x] CompletionKey = { file_hash, line, column, prefix_hash }
[x] CompletionItem = { label, kind, detail? }
[x] get() - returns cached (allows stale)
[x] put() - stores with freshness
[x] invalidateAll() - marks all stale on file change
[x] Statistics: hits, misses, stale_hits
[x] Unit tests: put/get, stale behavior, key hashing

DONE 6.2: Wire to LSP completion handler
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/lsp/server.zig, src/transam/transam.zig

[x] handleCompletion uses db.getCompletions() with cache lookup
[x] Stale results returned immediately + background refresh queued
[x] generateCompletions() scans file for symbols
[x] CompletionCache exported from transam.zig
```

### Phase 7: Network Cache L5 (P2) âœ… COMPLETE

**Goal:** @comptime fetch() cached across sessions

```
DONE 7.1: Disk-based network response cache
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/network_cache.zig (NEW FILE)

[x] NetworkCache with disk persistence
[x] Location: .metascript-cache/network/<url-hash>.json
[x] CachedResponse = { url, body, fetched_at, ttl, status_code, content_type }
[x] Default TTL: 24 hours (haxe-lsp pattern)
[x] get() - returns null if expired
[x] put() - stores to disk as JSON
[x] clear() - removes all cached responses
[x] Statistics: hits, misses, expired, errors
[x] Unit tests: put/get, expiration behavior

DONE 7.2: Integrate NetworkCache with Trans-Am
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Location: src/transam/transam.zig

[x] NetworkCache exported from transam.zig
[x] network_cache field in TransAmDatabase struct
[x] Initialized in init() with project root
[x] Cleaned up in deinit()

TODO 7.3: Wire to Hermes VM fetch() (future)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[ ] Implement @comptime fetch() in Hermes VM
[ ] Before network request: check L5 cache
[ ] On miss/expired: fetch, cache, return

TODO 7.4: Cache CLI commands (future)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[ ] msc cache clear --network
[ ] msc cache stats
```

---

## Files Created/Modified

```
NEW FILES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
src/transam/cache.zig            # LRU, FreshnessLRU, MacroOutputCache, CompletionCache
src/lsp/background_worker.zig    # Background job queue
src/transam/network_cache.zig    # Disk-based network response cache

MODIFIED:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
src/transam/transam.zig          # LRU caches, cancellation, slow tracking, NetworkCache
src/lsp/server.zig               # Cancellation wiring, BackgroundWorker, completion cache
src/checker/typechecker.zig      # Cancellation checkpoints
```

---

## Success Criteria

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         DONE WHEN                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Phase 1-4 (P0) Complete:                                                   â”‚
â”‚  [ ] Memory bounded at ~150MB (LRU eviction working)                        â”‚
â”‚  [ ] Rapid typing doesn't queue unbounded work (cancellation working)       â”‚
â”‚  [ ] Slow macros (>100ms) get warning, excluded from cache                  â”‚
â”‚  [ ] Diagnostics never stale (guard working)                                â”‚
â”‚                                                                             â”‚
â”‚  Performance Targets Met:                                                   â”‚
â”‚  [ ] Completion with cached macro: <50ms (L2 hit)                           â”‚
â”‚  [ ] Completion cold (macro expansion): <200ms                              â”‚
â”‚  [ ] Completion with slow macro: <50ms (fallback, no macro members)         â”‚
â”‚  [ ] Diagnostics: <500ms (always fresh)                                     â”‚
â”‚                                                                             â”‚
â”‚  Test Coverage:                                                             â”‚
â”‚  [ ] LRU cache unit tests passing                                           â”‚
â”‚  [ ] Cancellation integration test passing                                  â”‚
â”‚  [ ] Slow query tracking test passing                                       â”‚
â”‚  [ ] End-to-end LSP test with 1000+ macro classes                           â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Conclusion

**Success factors:**
1. LSP-first (not afterthought)
2. Incremental (cache + invalidate minimally)
3. Lazy (expand on-demand)
4. Separate (static syntax â‰  dynamic semantics)

**For Metascript:** Follow Rust/Zig playbook. Build LSP with same care as compiler.

---

## References

- [Rust-Analyzer: IDEs and Macros](https://rust-analyzer.github.io/blog/2021/11/21/ides-and-macros.html)
- [Matklad: ZLS and Cancellation](https://matklad.github.io/2023/05/06/zig-language-server-and-cancellation.html)
- [Nim RFC #300 - Tooling Crisis](https://github.com/nim-lang/RFCs/issues/300)
- [Haxe vshaxe #199 - Macro Overhead](https://github.com/vshaxe/vshaxe/issues/199)
