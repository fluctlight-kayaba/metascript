// Metascript Macro Test (.ms file)
// This demonstrates the power of compile-time metaprogramming

// Test 1: @derive macro - Auto-generate boilerplate
@derive(Eq, Hash)
class User {
    name: string;
    age: number;
}

// After macro expansion, the compiler generates:
// class User {
//     name: string;
//     age: number;
//
//     equals(other: User): boolean {
//         return this.name === other.name &&
//                this.age === other.age;
//     }
//
//     hash(): number {
//         return hashString(this.name) ^ this.age;
//     }
// }

// Test 2: Using the generated methods
function main(): void {
    const user1 = new User();
    user1.name = "Alice";
    user1.age = 30;

    const user2 = new User();
    user2.name = "Alice";
    user2.age = 30;

    // These methods were generated by @derive!
    if (user1.equals(user2)) {
        console.log("Users are equal");
    }

    const hash1 = user1.hash();
    const hash2 = user2.hash();
    console.log(`Hash 1: ${hash1}, Hash 2: ${hash2}`);
}

// Test 3: @comptime - Compile-time evaluation
const config = @comptime {
    const env = "production";
    return {
        apiUrl: env === "production"
            ? "https://api.prod.com"
            : "http://localhost:3000",
        debug: env === "development"
    };
};

// config is embedded in the binary at compile-time!
// No runtime overhead, pure constants

// Test 4: Multiple derives
@derive(Eq, Hash, Clone, Debug, Serialize)
class Product {
    id: number;
    name: string;
    price: number;
}

// Generates: equals(), hash(), clone(), toString(), toJSON(), fromJSON()
