const std = @import("std");
const ast = @import("../ast/ast.zig");

// Export normalize module for testing
pub const normalize = @import("normalize.zig");

/// Macro expansion context
pub const MacroContext = struct {
    arena: *ast.ASTArena,
    allocator: std.mem.Allocator,
    macros: MacroRegistry,
    errors: std.ArrayList(MacroError),

    pub const MacroError = struct {
        location: ast.SourceLocation,
        message: []const u8,
    };

    pub fn init(arena: *ast.ASTArena, allocator: std.mem.Allocator) MacroContext {
        return .{
            .arena = arena,
            .allocator = allocator,
            .macros = MacroRegistry.init(allocator),
            .errors = std.ArrayList(MacroError).init(allocator),
        };
    }

    pub fn deinit(self: *MacroContext) void {
        self.macros.deinit();
        self.errors.deinit();
    }

    /// Register a built-in macro
    pub fn registerMacro(self: *MacroContext, name: []const u8, func: MacroFunction) !void {
        try self.macros.put(name, func);
    }

    /// Report a macro expansion error
    pub fn reportError(self: *MacroContext, location: ast.SourceLocation, message: []const u8) !void {
        try self.errors.append(.{
            .location = location,
            .message = message,
        });
    }
};

/// Macro function signature
/// Takes a macro invocation node and returns expanded AST (or null on error)
pub const MacroFunction = *const fn (ctx: *MacroContext, invocation: *ast.Node) anyerror!?*ast.Node;

/// Registry of macro functions
pub const MacroRegistry = std.StringHashMap(MacroFunction);

/// Macro expander - performs AST → AST transformations
pub const MacroExpander = struct {
    ctx: *MacroContext,

    pub fn init(ctx: *MacroContext) MacroExpander {
        return .{ .ctx = ctx };
    }

    /// Expand all macros in the AST
    /// This is the CORE of metaprogramming!
    pub fn expandProgram(self: *MacroExpander, program: *ast.Node) !*ast.Node {
        std.debug.assert(program.kind == .program);

        // Pass 1: Find all macro invocations
        var macro_finder = MacroFinder.init(self.ctx.allocator);
        defer macro_finder.deinit();
        try macro_finder.visit(program);

        // Pass 2: Expand each macro invocation
        for (macro_finder.invocations.items) |invocation| {
            try self.expandMacroInvocation(invocation);
        }

        // Pass 3: Recursively expand any new macros generated by expansion
        // (macros can generate more macros!)
        if (macro_finder.invocations.items.len > 0) {
            return try self.expandProgram(program);
        }

        return program;
    }

    /// Expand a single macro invocation
    fn expandMacroInvocation(self: *MacroExpander, invocation: *ast.Node) !void {
        std.debug.assert(invocation.kind == .macro_invocation);
        const macro = &invocation.data.macro_invocation;

        // Look up the macro function
        const macro_func = self.ctx.macros.get(macro.name) orelse {
            try self.ctx.reportError(
                invocation.location,
                try std.fmt.allocPrint(self.ctx.allocator, "Unknown macro: @{s}", .{macro.name}),
            );
            return;
        };

        // Execute the macro function (AST → AST transformation!)
        const expanded = try macro_func(self.ctx, invocation);

        if (expanded) |new_node| {
            // Replace the macro invocation with the expanded AST
            // (This requires parent tracking, simplified here)
            invocation.* = new_node.*;
        }
    }
};

/// Visitor to find all macro invocations in the AST
const MacroFinder = struct {
    invocations: std.ArrayList(*ast.Node),
    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator) MacroFinder {
        return .{
            .invocations = std.ArrayList(*ast.Node).init(allocator),
            .allocator = allocator,
        };
    }

    pub fn deinit(self: *MacroFinder) void {
        self.invocations.deinit();
    }

    pub fn visit(self: *MacroFinder, node: *ast.Node) !void {
        // Check if this node is a macro invocation
        if (node.kind == .macro_invocation) {
            try self.invocations.append(node);
        }

        // Recursively visit children
        switch (node.kind) {
            .program => {
                const program = &node.data.program;
                for (program.statements) |stmt| {
                    try self.visit(stmt);
                }
            },
            .class_decl => {
                const class = &node.data.class_decl;
                for (class.members) |member| {
                    try self.visit(member);
                }
            },
            .block_stmt => {
                const block = &node.data.block_stmt;
                for (block.statements) |stmt| {
                    try self.visit(stmt);
                }
            },
            // Add more cases as needed
            else => {},
        }
    }
};

/// AST utility functions for macro implementations

/// Clone an AST node (deep copy)
pub fn cloneNode(arena: *ast.ASTArena, node: *const ast.Node) !*ast.Node {
    const new_node = try arena.createNode(node.kind, node.location, node.data);
    new_node.type = node.type;
    return new_node;
}

/// Create an identifier node
pub fn createIdentifier(arena: *ast.ASTArena, loc: ast.SourceLocation, name: []const u8) !*ast.Node {
    return try arena.createNode(
        .identifier,
        loc,
        .{ .identifier = name },
    );
}

/// Create a binary expression node
pub fn createBinaryExpr(
    arena: *ast.ASTArena,
    loc: ast.SourceLocation,
    op: ast.BinaryOp,
    left: *ast.Node,
    right: *ast.Node,
) !*ast.Node {
    return try arena.createNode(
        .binary_expr,
        loc,
        .{
            .binary_expr = .{
                .op = op,
                .left = left,
                .right = right,
            },
        },
    );
}

/// Create a method declaration node
pub fn createMethodDecl(
    arena: *ast.ASTArena,
    loc: ast.SourceLocation,
    name: []const u8,
    params: []ast.node.FunctionExpr.FunctionParam,
    return_type: ?*ast.Type,
    body: ?*ast.Node,
) !*ast.Node {
    return try arena.createNode(
        .method_decl,
        loc,
        .{
            .method_decl = .{
                .name = name,
                .type_params = &[_]ast.GenericParam{},
                .params = params,
                .return_type = return_type,
                .body = body,
            },
        },
    );
}

test "macro expander initialization" {
    var arena = ast.ASTArena.init(std.testing.allocator);
    defer arena.deinit();

    var ctx = MacroContext.init(&arena, std.testing.allocator);
    defer ctx.deinit();

    const expander = MacroExpander.init(&ctx);
    _ = expander;

    try std.testing.expect(ctx.errors.items.len == 0);
}

test "macro finder" {
    var arena = ast.ASTArena.init(std.testing.allocator);
    defer arena.deinit();

    // Create a program with a macro invocation
    const loc = ast.SourceLocation.dummy();
    const macro_node = try arena.createNode(
        .macro_invocation,
        loc,
        .{
            .macro_invocation = .{
                .name = "derive",
                .arguments = &[_]ast.node.MacroInvocation.MacroArgument{},
                .target = null,
            },
        },
    );

    const statements = try std.testing.allocator.alloc(*ast.Node, 1);
    defer std.testing.allocator.free(statements);
    statements[0] = macro_node;

    const program = try arena.createNode(
        .program,
        loc,
        .{
            .program = .{
                .statements = statements,
                .file_id = 1,
            },
        },
    );

    var finder = MacroFinder.init(std.testing.allocator);
    defer finder.deinit();

    try finder.visit(program);

    try std.testing.expectEqual(@as(usize, 1), finder.invocations.items.len);
    try std.testing.expectEqual(ast.NodeKind.macro_invocation, finder.invocations.items[0].kind);
}
