/*
 * Metascript StringBuilder - O(1) Amortized Append
 *
 * Performance Optimization for string concatenation loops.
 * Reduces O(nÂ²) malloc/memcpy to O(n) with exponential growth.
 *
 * Typical usage (generated by @StringBuilder macro):
 *   msStringBuilder sb;
 *   ms_sb_init(&sb, 64);           // Pre-allocate 64 bytes
 *   for (...) {
 *       ms_sb_append_cstr(&sb, "item");
 *       ms_sb_append_char(&sb, ',');
 *   }
 *   msString* result = ms_sb_build(&sb);  // Single allocation for result
 *   ms_sb_free(&sb);
 *
 * Memory Layout:
 *   StringBuilder owns a char* buffer that grows exponentially.
 *   Final ms_sb_build() creates an msString with exact-fit allocation.
 *
 * Growth Strategy:
 *   - Initial capacity: user-specified or 64 bytes
 *   - Growth factor: 2x (amortized O(1) append)
 *   - Max single growth: 1MB (prevent runaway allocation)
 */

#ifndef METASCRIPT_STRING_BUILDER_H
#define METASCRIPT_STRING_BUILDER_H

#include "ms_string.h"
#include <stdarg.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Default initial capacity */
#define MS_SB_DEFAULT_CAPACITY 64

/* Maximum single growth step (1MB) */
#define MS_SB_MAX_GROWTH (1024 * 1024)

/* Growth factor (2x) */
#define MS_SB_GROWTH_FACTOR 2

/*
 * StringBuilder Structure
 */
typedef struct {
    char* data;       /* Buffer (heap-allocated) */
    size_t len;       /* Current length */
    size_t capacity;  /* Allocated capacity */
} msStringBuilder;

/*
 * Initialize StringBuilder with specified capacity
 */
static inline void ms_sb_init(msStringBuilder* sb, size_t initial_capacity) {
    if (initial_capacity < MS_SB_DEFAULT_CAPACITY) {
        initial_capacity = MS_SB_DEFAULT_CAPACITY;
    }
    sb->data = (char*)malloc(initial_capacity);
    sb->len = 0;
    sb->capacity = initial_capacity;
    if (sb->data) {
        sb->data[0] = '\0';
    }
}

/*
 * Initialize with default capacity
 */
static inline void ms_sb_init_default(msStringBuilder* sb) {
    ms_sb_init(sb, MS_SB_DEFAULT_CAPACITY);
}

/*
 * Free StringBuilder buffer (does NOT free the struct itself)
 */
static inline void ms_sb_free(msStringBuilder* sb) {
    if (sb->data) {
        free(sb->data);
        sb->data = NULL;
        sb->len = 0;
        sb->capacity = 0;
    }
}

/*
 * Ensure capacity for additional bytes
 * Returns 1 on success, 0 on allocation failure
 */
static inline int ms_sb_ensure_capacity(msStringBuilder* sb, size_t additional) {
    size_t required = sb->len + additional + 1;  /* +1 for null terminator */

    if (required <= sb->capacity) {
        return 1;  /* Already have enough space */
    }

    /* Calculate new capacity with exponential growth */
    size_t new_capacity = sb->capacity;
    while (new_capacity < required) {
        size_t growth = new_capacity;
        if (growth > MS_SB_MAX_GROWTH) {
            growth = MS_SB_MAX_GROWTH;
        }
        new_capacity += growth;
    }

    /* Reallocate */
    char* new_data = (char*)realloc(sb->data, new_capacity);
    if (new_data == NULL) {
        return 0;  /* Allocation failed */
    }

    sb->data = new_data;
    sb->capacity = new_capacity;
    return 1;
}

/*
 * Append C string
 */
static inline void ms_sb_append_cstr(msStringBuilder* sb, const char* str) {
    if (str == NULL || sb->data == NULL) return;

    size_t str_len = strlen(str);
    if (str_len == 0) return;

    if (!ms_sb_ensure_capacity(sb, str_len)) return;

    memcpy(sb->data + sb->len, str, str_len);
    sb->len += str_len;
    sb->data[sb->len] = '\0';
}

/*
 * Append C string with known length (faster - no strlen)
 */
static inline void ms_sb_append_cstr_len(msStringBuilder* sb, const char* str, size_t len) {
    if (str == NULL || sb->data == NULL || len == 0) return;

    if (!ms_sb_ensure_capacity(sb, len)) return;

    memcpy(sb->data + sb->len, str, len);
    sb->len += len;
    sb->data[sb->len] = '\0';
}

/*
 * Append msString
 */
static inline void ms_sb_append_string(msStringBuilder* sb, msString* str) {
    if (str == NULL || sb->data == NULL) return;
    ms_sb_append_cstr_len(sb, str->data, str->len);
}

/*
 * Append single character
 */
static inline void ms_sb_append_char(msStringBuilder* sb, char c) {
    if (sb->data == NULL) return;

    if (!ms_sb_ensure_capacity(sb, 1)) return;

    sb->data[sb->len++] = c;
    sb->data[sb->len] = '\0';
}

/*
 * Append integer
 */
static inline void ms_sb_append_int(msStringBuilder* sb, int64_t num) {
    if (sb->data == NULL) return;

    char buf[32];
    int len = snprintf(buf, sizeof(buf), "%lld", (long long)num);
    if (len > 0) {
        ms_sb_append_cstr_len(sb, buf, (size_t)len);
    }
}

/*
 * Append unsigned integer
 */
static inline void ms_sb_append_uint(msStringBuilder* sb, uint64_t num) {
    if (sb->data == NULL) return;

    char buf[32];
    int len = snprintf(buf, sizeof(buf), "%llu", (unsigned long long)num);
    if (len > 0) {
        ms_sb_append_cstr_len(sb, buf, (size_t)len);
    }
}

/*
 * Append double
 */
static inline void ms_sb_append_double(msStringBuilder* sb, double num) {
    if (sb->data == NULL) return;

    char buf[64];
    int len = snprintf(buf, sizeof(buf), "%g", num);
    if (len > 0) {
        ms_sb_append_cstr_len(sb, buf, (size_t)len);
    }
}

/*
 * Append boolean
 */
static inline void ms_sb_append_bool(msStringBuilder* sb, bool val) {
    if (val) {
        ms_sb_append_cstr_len(sb, "true", 4);
    } else {
        ms_sb_append_cstr_len(sb, "false", 5);
    }
}

/*
 * Append formatted string (printf-style)
 */
static inline void ms_sb_append_fmt(msStringBuilder* sb, const char* fmt, ...) {
    if (sb->data == NULL || fmt == NULL) return;

    va_list args;
    va_start(args, fmt);

    /* First, determine required size */
    va_list args_copy;
    va_copy(args_copy, args);
    int required = vsnprintf(NULL, 0, fmt, args_copy);
    va_end(args_copy);

    if (required <= 0) {
        va_end(args);
        return;
    }

    if (!ms_sb_ensure_capacity(sb, (size_t)required)) {
        va_end(args);
        return;
    }

    /* Now format into buffer */
    vsnprintf(sb->data + sb->len, (size_t)required + 1, fmt, args);
    sb->len += (size_t)required;

    va_end(args);
}

/*
 * Build final msString from StringBuilder
 * Returns ORC-managed string (caller owns the reference)
 * StringBuilder can be reused after this call
 */
static inline msString* ms_sb_build(msStringBuilder* sb) {
    if (sb->data == NULL) {
        return ms_string_empty();
    }
    return ms_string_new(sb->data, sb->len);
}

/*
 * Build and clear StringBuilder
 * Returns ORC-managed string, resets builder for reuse
 */
static inline msString* ms_sb_build_and_clear(msStringBuilder* sb) {
    msString* result = ms_sb_build(sb);
    sb->len = 0;
    if (sb->data) {
        sb->data[0] = '\0';
    }
    return result;
}

/*
 * Get current length
 */
static inline size_t ms_sb_len(msStringBuilder* sb) {
    return sb->len;
}

/*
 * Check if empty
 */
static inline bool ms_sb_is_empty(msStringBuilder* sb) {
    return sb->len == 0;
}

/*
 * Clear contents (keep capacity)
 */
static inline void ms_sb_clear(msStringBuilder* sb) {
    sb->len = 0;
    if (sb->data) {
        sb->data[0] = '\0';
    }
}

/*
 * Reserve additional capacity
 */
static inline void ms_sb_reserve(msStringBuilder* sb, size_t additional) {
    ms_sb_ensure_capacity(sb, additional);
}

/*
 * Shrink capacity to fit current content
 */
static inline void ms_sb_shrink_to_fit(msStringBuilder* sb) {
    if (sb->data == NULL || sb->len + 1 >= sb->capacity) return;

    size_t new_capacity = sb->len + 1;
    char* new_data = (char*)realloc(sb->data, new_capacity);
    if (new_data) {
        sb->data = new_data;
        sb->capacity = new_capacity;
    }
}

/*
 * ============================================================================
 * Pre-sized StringBuilder for Compile-Time Optimization
 * ============================================================================
 *
 * When the compiler can estimate loop bounds, it generates code like:
 *   msStringBuilder sb;
 *   ms_sb_init_presized(&sb, estimated_size);
 *
 * This eliminates most reallocations.
 */

/*
 * Initialize with pre-estimated size
 * Use when compiler can estimate final string length
 */
static inline void ms_sb_init_presized(msStringBuilder* sb, size_t estimated_size) {
    /* Add 25% buffer for safety */
    size_t capacity = estimated_size + (estimated_size / 4) + 1;
    if (capacity < MS_SB_DEFAULT_CAPACITY) {
        capacity = MS_SB_DEFAULT_CAPACITY;
    }
    ms_sb_init(sb, capacity);
}

/*
 * ============================================================================
 * Batch Append Operations (for codegen optimization)
 * ============================================================================
 */

/*
 * Append multiple C strings at once
 * More efficient than multiple ms_sb_append_cstr calls
 */
static inline void ms_sb_append_many(msStringBuilder* sb, int count, ...) {
    if (sb->data == NULL || count <= 0) return;

    va_list args;
    va_start(args, count);

    /* First pass: calculate total length */
    size_t total_len = 0;
    va_list args_copy;
    va_copy(args_copy, args);
    for (int i = 0; i < count; i++) {
        const char* str = va_arg(args_copy, const char*);
        if (str) total_len += strlen(str);
    }
    va_end(args_copy);

    /* Ensure capacity once */
    if (!ms_sb_ensure_capacity(sb, total_len)) {
        va_end(args);
        return;
    }

    /* Second pass: append all strings */
    for (int i = 0; i < count; i++) {
        const char* str = va_arg(args, const char*);
        if (str) {
            size_t len = strlen(str);
            memcpy(sb->data + sb->len, str, len);
            sb->len += len;
        }
    }
    sb->data[sb->len] = '\0';

    va_end(args);
}

#ifdef __cplusplus
}
#endif

#endif /* METASCRIPT_STRING_BUILDER_H */
