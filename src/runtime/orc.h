/*
 * Metascript ORC (Optimized Reference Counting) Runtime
 * Header-only C library for codegen backends
 *
 * Based on Nim's ORC and Bacon-Rajan cycle collection algorithm.
 *
 * ============================================================================
 * USAGE (Header-Only Library Pattern)
 * ============================================================================
 *
 * In EXACTLY ONE .c file, define MS_ORC_IMPLEMENTATION before including:
 *
 *     #define MS_ORC_IMPLEMENTATION
 *     #include "orc.h"
 *
 * In all other .c files, include normally (declarations only):
 *
 *     #include "orc.h"
 *
 * WARNING: If you include this header in multiple .c files WITHOUT defining
 * MS_ORC_IMPLEMENTATION in exactly one of them, you will get linker errors
 * (multiple definitions). If you define it in MORE than one, you will get
 * duplicate storage and cycle detection will silently fail.
 *
 * For single-file programs, you can define MS_ORC_IMPLEMENTATION before
 * including, or just use as-is (defaults to implementation mode if no
 * other translation unit defines it).
 *
 * ============================================================================
 * THREAD SAFETY
 * ============================================================================
 *
 * NOT THREAD SAFE. All operations on the same object graph must be performed
 * from a single thread. For multi-threaded applications, use separate ORC
 * instances per thread or add external synchronization.
 *
 * ============================================================================
 * MEMORY LAYOUT
 * ============================================================================
 *
 *   [RefHeader (8 bytes)][User Data]
 *
 * RefHeader:
 *   - rc (4 bytes): Reference count
 *   - flags (1 byte): color (2 bits), buffered (1 bit), reserved (5 bits)
 *   - type_id (3 bytes): Type registry index for cycle tracing
 *
 * ============================================================================
 * KEY DESIGN: Caller-Provides-Type Pattern
 * ============================================================================
 *
 *   - TypeInfo is NOT stored in each object (saves 8 bytes per object)
 *   - Caller passes TypeInfo to functions that need it
 *   - Compiler generates one static TypeInfo per class
 *   - type_id in header enables looking up TypeInfo during cycle tracing
 *
 * ============================================================================
 * BASIC USAGE
 * ============================================================================
 *
 *   // Simple allocation (no cycle detection)
 *   User* user = (User*)ms_alloc(sizeof(User));
 *   ms_incref(user);
 *   ms_decref(user);
 *
 *   // With type info (enables cycle detection)
 *   User* user = (User*)ms_alloc(sizeof(User));
 *   ms_set_type(user, &User_type_info);        // Register type for tracing
 *   ms_decref_typed(user, &User_type_info);    // Caller provides type
 *   ms_collect_cycles();                        // Run cycle collector
 */

#ifndef METASCRIPT_ORC_H
#define METASCRIPT_ORC_H

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Bacon-Rajan colors for cycle detection
 */
typedef enum {
    MS_COLOR_BLACK = 0,   /* In use or free (default) */
    MS_COLOR_PURPLE = 1,  /* Possible root of garbage cycle */
    MS_COLOR_GRAY = 2,    /* Candidate for collection */
    MS_COLOR_WHITE = 3,   /* Garbage (part of cycle) */
} msColor;

/*
 * Trace callback type: called for each ref field in an object
 */
typedef void (*msTraceCallback)(void* child);

/*
 * Trace function type: iterates over ref fields in an object
 */
typedef void (*msTraceFn)(void* obj, msTraceCallback callback);

/*
 * Destructor function type: called before freeing
 */
typedef void (*msDestroyFn)(void* obj);

/*
 * Type metadata for cycle detection (matches Nim ORC)
 * Generated by codegen for each class
 */
typedef struct msTypeInfo {
    const char* name;       /* Type name (for debugging) */
    size_t size;            /* Size of type */
    bool is_cyclic;         /* Can form cycles? (compile-time) */
    msTraceFn trace_fn;     /* Trace function (may be NULL) */
    msDestroyFn destroy_fn; /* Destructor (may be NULL) */
} msTypeInfo;

/*
 * Flags packed into 1 byte (matches Nim ORC)
 * Bit layout: [color:2][buffered:1][_reserved:5]
 *
 * Note: is_cyclic is NOT stored here - it's compile-time determined
 * and passed via TypeInfo by the caller.
 */
typedef struct {
    uint8_t color : 2;      /* Bacon-Rajan color (BLACK, PURPLE, GRAY, WHITE) */
    uint8_t buffered : 1;   /* In root list for cycle detection */
    uint8_t _reserved : 5;  /* Reserved for future use */
} msFlags;

/*
 * Reference Header (8 bytes)
 * Layout: [rc:4][flags:1][type_id:3]
 *
 * type_id enables looking up TypeInfo during cycle tracing.
 * This allows tracing children that weren't directly decremented.
 * 24-bit type_id supports up to 16 million types.
 */
typedef struct {
    uint32_t rc;                    /* Reference count */
    msFlags flags;                  /* Flags */
    uint8_t type_id[3];             /* Type registry index (24-bit, little-endian) */
} msRefHeader;

/* Helper to get/set type_id (24-bit value from 3 bytes) */
static inline uint32_t ms_get_type_id(msRefHeader* header) {
    return (uint32_t)header->type_id[0] |
           ((uint32_t)header->type_id[1] << 8) |
           ((uint32_t)header->type_id[2] << 16);
}

static inline void ms_set_type_id(msRefHeader* header, uint32_t id) {
    header->type_id[0] = (uint8_t)(id & 0xFF);
    header->type_id[1] = (uint8_t)((id >> 8) & 0xFF);
    header->type_id[2] = (uint8_t)((id >> 16) & 0xFF);
}

/*
 * Configuration
 */
#ifndef MS_MAX_ROOTS
#define MS_MAX_ROOTS 1024
#endif

#ifndef MS_CYCLE_THRESHOLD
#define MS_CYCLE_THRESHOLD 100
#endif

#ifndef MS_MAX_TYPES
#define MS_MAX_TYPES 4096
#endif

/*
 * ============================================================================
 * STORAGE DECLARATIONS
 * ============================================================================
 *
 * For multi-TU builds: globals are declared extern here, defined in the
 * implementation section below (when MS_ORC_IMPLEMENTATION is defined).
 *
 * For single-file builds: if MS_ORC_IMPLEMENTATION isn't defined anywhere,
 * we auto-define it so the header works standalone.
 */

/* Auto-define implementation for single-file usage */
#ifndef MS_ORC_EXTERN
    #ifdef MS_ORC_IMPLEMENTATION
        #define MS_ORC_EXTERN
    #else
        #define MS_ORC_EXTERN extern
    #endif
#endif

/*
 * Type Registry - maps type_id to TypeInfo
 * Type ID 0 is reserved for "unknown type"
 */
MS_ORC_EXTERN const msTypeInfo* ms_type_registry[MS_MAX_TYPES];
MS_ORC_EXTERN size_t ms_type_count;

/*
 * Register a type and get its ID (idempotent - returns existing ID if already registered)
 */
static inline uint32_t ms_register_type(const msTypeInfo* type_info) {
    if (type_info == NULL) return 0;

    /* Check if already registered */
    for (size_t i = 1; i < ms_type_count; i++) {
        if (ms_type_registry[i] == type_info) {
            return (uint32_t)i;
        }
    }

    /* Register new type */
    if (ms_type_count >= MS_MAX_TYPES) {
        /* Registry full - fall back to no type tracking */
        return 0;
    }

    uint32_t id = (uint32_t)ms_type_count;
    ms_type_registry[id] = type_info;
    ms_type_count++;
    return id;
}

/*
 * Look up TypeInfo by type_id
 */
static inline const msTypeInfo* ms_get_type_info(uint32_t type_id) {
    if (type_id == 0 || type_id >= ms_type_count) return NULL;
    return ms_type_registry[type_id];
}

/*
 * Root entry: stores header pointer for cycle collection
 * (TypeInfo now looked up via type_id in header)
 */
typedef struct {
    msRefHeader* header;
} msRootEntry;

/*
 * Global state (see STORAGE DECLARATIONS above for multi-TU pattern)
 */
MS_ORC_EXTERN msRootEntry ms_roots[MS_MAX_ROOTS];
MS_ORC_EXTERN size_t ms_root_count;
MS_ORC_EXTERN uint64_t ms_stats_allocations;
MS_ORC_EXTERN uint64_t ms_stats_deallocations;
MS_ORC_EXTERN uint64_t ms_stats_cycle_collections;
MS_ORC_EXTERN uint64_t ms_stats_acyclic_skipped;

/* Forward declaration */
static inline void ms_collect_cycles(void);

/*
 * Get RefHeader from user data pointer
 */
static inline msRefHeader* ms_get_header(void* ptr) {
    return (msRefHeader*)((char*)ptr - sizeof(msRefHeader));
}

/*
 * Allocate memory with DRC header
 * type_id is set to 0 (unknown) - call ms_set_type after allocation
 * or use ms_alloc_typed for typed allocation
 */
static inline void* ms_alloc(size_t size) {
    void* mem = malloc(sizeof(msRefHeader) + size);
    if (mem == NULL) return NULL;

    msRefHeader* header = (msRefHeader*)mem;
    header->rc = 1;
    header->flags.color = MS_COLOR_BLACK;
    header->flags.buffered = 0;
    header->flags._reserved = 0;
    ms_set_type_id(header, 0);  /* Unknown type initially */

    ms_stats_allocations++;
    return (char*)mem + sizeof(msRefHeader);
}

/*
 * Set type info for an object (registers type if needed)
 * Should be called once after allocation for cyclic types
 */
static inline void ms_set_type(void* ptr, const msTypeInfo* type_info) {
    if (ptr == NULL || type_info == NULL) return;
    msRefHeader* header = ms_get_header(ptr);
    uint32_t type_id = ms_register_type(type_info);
    ms_set_type_id(header, type_id);
}

/*
 * Increment reference count
 */
static inline void ms_incref(void* ptr) {
    if (ptr == NULL) return;

    msRefHeader* header = ms_get_header(ptr);
    header->rc++;
    header->flags.color = MS_COLOR_BLACK;
}

/*
 * Add to cycle roots (internal)
 * TypeInfo is looked up from header's type_id
 */
static inline void ms_add_to_roots(msRefHeader* header) {
    if (header->flags.buffered) return;
    if (ms_root_count >= MS_MAX_ROOTS) return;

    header->flags.buffered = 1;
    ms_roots[ms_root_count].header = header;
    ms_root_count++;
}

/*
 * Remove from cycle roots (internal)
 */
static inline void ms_remove_from_roots(msRefHeader* header) {
    if (!header->flags.buffered) return;

    /* Find and remove (swap with last) */
    for (size_t i = 0; i < ms_root_count; i++) {
        if (ms_roots[i].header == header) {
            ms_roots[i] = ms_roots[ms_root_count - 1];
            ms_root_count--;
            break;
        }
    }
    header->flags.buffered = 0;
}

/*
 * Free object (internal)
 * Looks up type_info from header's type_id if not provided
 */
static inline void ms_free_object(void* ptr, msRefHeader* header, const msTypeInfo* type_info) {
    /* Look up type from registry if not provided */
    if (type_info == NULL) {
        uint32_t type_id = ms_get_type_id(header);
        type_info = ms_get_type_info(type_id);
    }

    /* Call destructor if present */
    if (type_info && type_info->destroy_fn) {
        type_info->destroy_fn(ptr);
    }

    /* Remove from roots if present */
    if (header->flags.buffered) {
        ms_remove_from_roots(header);
    }

    /* Free memory */
    free(header);
    ms_stats_deallocations++;
}

/*
 * Decrement reference count, free if rc=0 (simple, no cycle check)
 * Use for acyclic types or when caller knows no cycle possible.
 */
static inline void ms_decref(void* ptr) {
    if (ptr == NULL) return;

    msRefHeader* header = ms_get_header(ptr);

    #ifdef DEBUG
    if (header->rc == 0) {
        fprintf(stderr, "ERROR: ms_decref called on freed pointer\n");
        abort();
    }
    #endif

    header->rc--;

    if (header->rc == 0) {
        ms_free_object(ptr, header, NULL);
    } else {
        header->flags.color = MS_COLOR_BLACK;
    }
}

/*
 * Decrement with cycle check (caller provides type info)
 * Adds to roots if rc > 0 and type is cyclic.
 *
 * IMPORTANT: Also sets the type_id in header so that cycle tracing
 * can find TypeInfo for this object and its children.
 */
static inline void ms_decref_typed(void* ptr, const msTypeInfo* type_info) {
    if (ptr == NULL) return;

    msRefHeader* header = ms_get_header(ptr);

    #ifdef DEBUG
    if (header->rc == 0) {
        fprintf(stderr, "ERROR: ms_decref_typed called on freed pointer\n");
        abort();
    }
    #endif

    /* Register type and store type_id in header for cycle tracing */
    if (type_info != NULL) {
        uint32_t type_id = ms_register_type(type_info);
        ms_set_type_id(header, type_id);
    }

    header->rc--;

    if (header->rc == 0) {
        ms_free_object(ptr, header, type_info);
    } else {
        /* Skip cycle detection for acyclic types (Nim ORC optimization) */
        if (!type_info || !type_info->is_cyclic) {
            ms_stats_acyclic_skipped++;
            return;
        }

        /* Potential cycle root */
        header->flags.color = MS_COLOR_PURPLE;
        ms_add_to_roots(header);

        /* Trigger collection if threshold reached */
        if (ms_root_count >= MS_CYCLE_THRESHOLD) {
            ms_collect_cycles();
        }
    }
}

/*
 * Mark gray callback - decrement children's RC during trial deletion
 * Uses type_id from header to look up TypeInfo for recursive tracing
 */
static void ms_mark_gray_callback(void* child) {
    msRefHeader* header = ms_get_header(child);
#ifdef DEBUG_ORC
    printf("[ORC]   mark_gray_callback: child rc=%u -> ", header->rc);
#endif
    if (header->rc > 0) header->rc--;
#ifdef DEBUG_ORC
    printf("%u\n", header->rc);
#endif
    /* Mark child gray and recursively trace if possible */
    if (header->flags.color != MS_COLOR_GRAY) {
        header->flags.color = MS_COLOR_GRAY;

        /* Look up child's type from type_id stored in header */
        uint32_t type_id = ms_get_type_id(header);
        const msTypeInfo* child_type = ms_get_type_info(type_id);
        if (child_type && child_type->trace_fn) {
            void* child_obj = (char*)header + sizeof(msRefHeader);
#ifdef DEBUG_ORC
            printf("[ORC]     Recursively tracing child %s\n", child_type->name);
#endif
            child_type->trace_fn(child_obj, ms_mark_gray_callback);
        }
    }
}

/*
 * Mark object gray (trial deletion) - entry point from collect_cycles
 * type_info is used to call trace_fn
 */
static void ms_mark_gray(msRefHeader* header, void* obj, const msTypeInfo* type_info) {
    if (header->flags.color != MS_COLOR_GRAY) {
        header->flags.color = MS_COLOR_GRAY;

        /* Trace children - decrement their RC and recursively trace */
        if (type_info && type_info->trace_fn) {
#ifdef DEBUG_ORC
            printf("[ORC]   Calling trace_fn for %s\n", type_info->name);
#endif
            type_info->trace_fn(obj, ms_mark_gray_callback);
        }
#ifdef DEBUG_ORC
        else {
            printf("[ORC]   No trace_fn! type_info=%p\n", (void*)type_info);
        }
#endif
    }
}

/*
 * Scan black callback - restore children's RC and recursively trace
 *
 * IMPORTANT: Must recurse to match mark_gray's recursive decrement.
 * Without recursion, RCs become corrupted for deep object graphs.
 */
static void ms_scan_black_callback(void* child) {
    msRefHeader* header = ms_get_header(child);
    header->rc++;

    if (header->flags.color != MS_COLOR_BLACK) {
        header->flags.color = MS_COLOR_BLACK;

        /* Recursively trace children to restore their RCs too */
        uint32_t type_id = ms_get_type_id(header);
        const msTypeInfo* child_type = ms_get_type_info(type_id);
        if (child_type && child_type->trace_fn) {
            void* child_obj = (char*)header + sizeof(msRefHeader);
            child_type->trace_fn(child_obj, ms_scan_black_callback);
        }
    }
}

/*
 * Mark object black (live)
 */
static void ms_scan_black(msRefHeader* header, void* obj, const msTypeInfo* type_info) {
    header->flags.color = MS_COLOR_BLACK;

    if (type_info && type_info->trace_fn) {
        type_info->trace_fn(obj, ms_scan_black_callback);
    }
}

/*
 * Scan callback - recursively scan gray children
 */
static void ms_scan_callback(void* child) {
    msRefHeader* header = ms_get_header(child);

    if (header->flags.color == MS_COLOR_GRAY) {
        if (header->rc > 0) {
            /* Child has external refs - mark black and restore children */
            uint32_t type_id = ms_get_type_id(header);
            const msTypeInfo* child_type = ms_get_type_info(type_id);
            void* child_obj = (char*)header + sizeof(msRefHeader);
            ms_scan_black(header, child_obj, child_type);
        } else {
            /* Mark as garbage */
            header->flags.color = MS_COLOR_WHITE;
            /* Continue scanning children */
            uint32_t type_id = ms_get_type_id(header);
            const msTypeInfo* child_type = ms_get_type_info(type_id);
            if (child_type && child_type->trace_fn) {
                void* child_obj = (char*)header + sizeof(msRefHeader);
                child_type->trace_fn(child_obj, ms_scan_callback);
            }
        }
    }
}

/*
 * Scan object - if RC > 0 mark black (live), else mark white (garbage)
 * Also recursively scans children to handle objects not in roots.
 */
static void ms_scan(msRefHeader* header, void* obj, const msTypeInfo* type_info) {
    if (header->flags.color == MS_COLOR_GRAY) {
        if (header->rc > 0) {
            ms_scan_black(header, obj, type_info);
        } else {
            header->flags.color = MS_COLOR_WHITE;
            /* Recursively scan children */
            if (type_info && type_info->trace_fn) {
                type_info->trace_fn(obj, ms_scan_callback);
            }
        }
    }
}

/*
 * Collect (free) a WHITE object and its WHITE children recursively.
 *
 * ELEGANT O(1) DESIGN:
 * - Check color != WHITE at entry → skip already-processed objects
 * - Mark BLACK immediately → prevent re-entry during recursion
 * - Trace children first (depth-first) → children freed before parent
 * - Then free this object
 *
 * No temporary arrays needed. No O(n) searches. Just recursive traversal
 * with proper state management.
 */
static void ms_collect_white_callback(void* child);

static void ms_collect_white(msRefHeader* header) {
    /* Only process WHITE objects - skip BLACK/GRAY/already-collected */
    if (header->flags.color != MS_COLOR_WHITE) return;

    /* Mark BLACK immediately to prevent re-entry during recursion */
    header->flags.color = MS_COLOR_BLACK;

    uint32_t type_id = ms_get_type_id(header);
    const msTypeInfo* type_info = ms_get_type_info(type_id);
    void* obj = (char*)header + sizeof(msRefHeader);

#ifdef DEBUG_ORC
    printf("[ORC]   Collecting: %s\n", type_info ? type_info->name : "unknown");
#endif

    /* First, recursively collect WHITE children (depth-first post-order) */
    if (type_info && type_info->trace_fn) {
        type_info->trace_fn(obj, ms_collect_white_callback);
    }

    /* Now free this object (children already freed) */
    header->flags.buffered = 0;
    if (type_info && type_info->destroy_fn) {
        type_info->destroy_fn(obj);
    }
    free(header);
    ms_stats_deallocations++;
}

static void ms_collect_white_callback(void* child) {
    msRefHeader* header = ms_get_header(child);
    ms_collect_white(header);
}

/*
 * Run Bacon-Rajan cycle collection
 *
 * Three phases:
 * 1. Mark Gray: Trial deletion - decrement children's RC
 * 2. Scan: If RC > 0 → live (BLACK), else → garbage (WHITE)
 * 3. Collect: Recursively free WHITE objects
 *
 * Key insight: Each function guards itself with color checks, making
 * redundant processing harmless. No need for NULL-ing or temporary arrays.
 */
static inline void ms_collect_cycles(void) {
    if (ms_root_count == 0) return;

    ms_stats_cycle_collections++;

#ifdef DEBUG_ORC
    printf("[ORC] collect_cycles: %zu roots\n", ms_root_count);
#endif

    /* Phase 1: Mark gray (trial deletion)
     * - PURPLE roots get mark_gray'd (recursive decrement)
     * - Non-PURPLE roots already processed by recursive mark_gray
     */
    for (size_t i = 0; i < ms_root_count; i++) {
        msRefHeader* header = ms_roots[i].header;
        if (header->flags.color == MS_COLOR_PURPLE) {
            uint32_t type_id = ms_get_type_id(header);
            const msTypeInfo* type_info = ms_get_type_info(type_id);
            void* obj = (char*)header + sizeof(msRefHeader);
#ifdef DEBUG_ORC
            printf("[ORC] Phase1 root[%zu]: PURPLE rc=%u\n", i, header->rc);
#endif
            ms_mark_gray(header, obj, type_info);
        } else {
            /* Already GRAY from recursive mark_gray - just clear buffered flag */
            header->flags.buffered = 0;
#ifdef DEBUG_ORC
            printf("[ORC] Phase1 root[%zu]: already %d, skipped\n", i, header->flags.color);
#endif
        }
    }

    /* Phase 2: Scan - determine live vs garbage
     * - ms_scan checks color==GRAY, so non-GRAY roots are skipped
     * - RC > 0 after trial deletion → live (mark BLACK, restore children)
     * - RC == 0 → garbage (mark WHITE)
     */
    for (size_t i = 0; i < ms_root_count; i++) {
        msRefHeader* header = ms_roots[i].header;
        uint32_t type_id = ms_get_type_id(header);
        const msTypeInfo* type_info = ms_get_type_info(type_id);
        void* obj = (char*)header + sizeof(msRefHeader);
#ifdef DEBUG_ORC
        printf("[ORC] Phase2 root[%zu]: rc=%u color=%d\n", i, header->rc, header->flags.color);
#endif
        ms_scan(header, obj, type_info);
    }

    /* Phase 3: Collect garbage (WHITE objects)
     * - ms_collect_white checks color==WHITE, skips non-WHITE
     * - Marks BLACK immediately to prevent double-free
     * - Recursively frees children first (depth-first post-order)
     */
#ifdef DEBUG_ORC
    printf("[ORC] Phase3: Collecting garbage\n");
#endif
    for (size_t i = 0; i < ms_root_count; i++) {
        msRefHeader* header = ms_roots[i].header;
#ifdef DEBUG_ORC
        printf("[ORC] Phase3 root[%zu]: rc=%u color=%d\n", i, header->rc, header->flags.color);
#endif
        if (header->flags.color == MS_COLOR_WHITE) {
            ms_collect_white(header);
        } else {
            /* Live object - reset to clean state */
            header->flags.color = MS_COLOR_BLACK;
            header->flags.buffered = 0;
        }
    }

    /* All roots processed - clear the list */
    ms_root_count = 0;

#ifdef DEBUG_ORC
    printf("[ORC] Collect done\n");
#endif
}

/*
 * Query functions
 */
static inline uint32_t ms_getrc(void* ptr) {
    if (ptr == NULL) return 0;
    return ms_get_header(ptr)->rc;
}

static inline msColor ms_getcolor(void* ptr) {
    if (ptr == NULL) return MS_COLOR_BLACK;
    return (msColor)ms_get_header(ptr)->flags.color;
}

/*
 * Note: ms_is_cyclic removed - cyclicity is now compile-time determined
 * and passed via TypeInfo. Use type_info->is_cyclic instead.
 */

static inline bool ms_is_in_roots(void* ptr) {
    if (ptr == NULL) return false;
    return ms_get_header(ptr)->flags.buffered;
}

static inline size_t ms_get_root_count(void) {
    return ms_root_count;
}

/*
 * Clear all roots (for testing - ensures clean state between tests)
 */
static inline void ms_clear_roots(void) {
    for (size_t i = 0; i < ms_root_count; i++) {
        ms_roots[i].header->flags.buffered = 0;
    }
    ms_root_count = 0;
}

/*
 * Move semantics helpers
 */
static inline void* ms_sink(void* ptr) {
    return ptr; /* No-op, ownership transferred */
}

static inline void* ms_clone(void* ptr) {
    ms_incref(ptr);
    return ptr;
}

/*
 * Statistics
 */
typedef struct {
    uint64_t allocations;
    uint64_t deallocations;
    uint64_t cycle_collections;
    uint64_t acyclic_skipped;
    size_t root_count;
} msStats;

static inline msStats ms_get_stats(void) {
    return (msStats){
        .allocations = ms_stats_allocations,
        .deallocations = ms_stats_deallocations,
        .cycle_collections = ms_stats_cycle_collections,
        .acyclic_skipped = ms_stats_acyclic_skipped,
        .root_count = ms_root_count,
    };
}

#ifdef __cplusplus
}
#endif

/*
 * ============================================================================
 * IMPLEMENTATION SECTION
 * ============================================================================
 *
 * This section is only compiled when MS_ORC_IMPLEMENTATION is defined.
 * Define it in exactly ONE .c file before including this header.
 */
#ifdef MS_ORC_IMPLEMENTATION

/* Storage definitions (declared extern above) */
const msTypeInfo* ms_type_registry[MS_MAX_TYPES] = {0};
size_t ms_type_count = 1;  /* Start at 1, 0 is reserved for "unknown" */
msRootEntry ms_roots[MS_MAX_ROOTS] = {0};
size_t ms_root_count = 0;
uint64_t ms_stats_allocations = 0;
uint64_t ms_stats_deallocations = 0;
uint64_t ms_stats_cycle_collections = 0;
uint64_t ms_stats_acyclic_skipped = 0;

#endif /* MS_ORC_IMPLEMENTATION */

#endif /* METASCRIPT_ORC_H */
