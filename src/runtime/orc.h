/*
 * Metascript ORC (Optimized Reference Counting) Runtime
 * Header-only C library for codegen backends
 *
 * Based on Nim's ORC and Bacon-Rajan cycle collection algorithm.
 *
 * ============================================================================
 * USAGE (Header-Only Library Pattern)
 * ============================================================================
 *
 * In EXACTLY ONE .c file, define MS_ORC_IMPLEMENTATION before including:
 *
 *     #define MS_ORC_IMPLEMENTATION
 *     #include "orc.h"
 *
 * In all other .c files, include normally (declarations only):
 *
 *     #include "orc.h"
 *
 * WARNING: If you include this header in multiple .c files WITHOUT defining
 * MS_ORC_IMPLEMENTATION in exactly one of them, you will get linker errors
 * (multiple definitions). If you define it in MORE than one, you will get
 * duplicate storage and cycle detection will silently fail.
 *
 * For single-file programs, you can define MS_ORC_IMPLEMENTATION before
 * including, or just use as-is (defaults to implementation mode if no
 * other translation unit defines it).
 *
 * ============================================================================
 * THREAD SAFETY
 * ============================================================================
 *
 * NOT THREAD SAFE. All operations on the same object graph must be performed
 * from a single thread. For multi-threaded applications, use separate ORC
 * instances per thread or add external synchronization.
 *
 * ============================================================================
 * MEMORY LAYOUT
 * ============================================================================
 *
 *   [RefHeader (8 bytes)][User Data]
 *
 * RefHeader:
 *   - rc (4 bytes): Reference count
 *   - flags (1 byte): color (2 bits), buffered (1 bit), reserved (5 bits)
 *   - type_id (3 bytes): Type registry index for cycle tracing
 *
 * ============================================================================
 * KEY DESIGN: Caller-Provides-Type Pattern
 * ============================================================================
 *
 *   - TypeInfo is NOT stored in each object (saves 8 bytes per object)
 *   - Caller passes TypeInfo to functions that need it
 *   - Compiler generates one static TypeInfo per class
 *   - type_id in header enables looking up TypeInfo during cycle tracing
 *
 * ============================================================================
 * BASIC USAGE
 * ============================================================================
 *
 *   // Simple allocation (no cycle detection)
 *   User* user = (User*)ms_alloc(sizeof(User));
 *   ms_incref(user);
 *   ms_decref(user);
 *
 *   // With type info (enables cycle detection)
 *   User* user = (User*)ms_alloc(sizeof(User));
 *   ms_set_type(user, &User_type_info);        // Register type for tracing
 *   ms_decref_typed(user, &User_type_info);    // Caller provides type
 *   ms_collect_cycles();                        // Run cycle collector
 */

#ifndef METASCRIPT_ORC_H
#define METASCRIPT_ORC_H

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Bacon-Rajan colors for cycle detection
 */
typedef enum {
    MS_COLOR_BLACK = 0,   /* In use or free (default) */
    MS_COLOR_PURPLE = 1,  /* Possible root of garbage cycle */
    MS_COLOR_GRAY = 2,    /* Candidate for collection */
    MS_COLOR_WHITE = 3,   /* Garbage (part of cycle) */
} msColor;

/*
 * Trace callback type: called for each ref field in an object
 */
typedef void (*msTraceCallback)(void* child);

/*
 * Trace function type: iterates over ref fields in an object
 */
typedef void (*msTraceFn)(void* obj, msTraceCallback callback);

/*
 * Destructor function type: called before freeing
 */
typedef void (*msDestroyFn)(void* obj);

/*
 * Type metadata for cycle detection (matches Nim ORC)
 * Generated by codegen for each class
 */
typedef struct msTypeInfo {
    const char* name;       /* Type name (for debugging) */
    size_t size;            /* Size of type */
    bool is_cyclic;         /* Can form cycles? (compile-time) */
    msTraceFn trace_fn;     /* Trace function (may be NULL) */
    msDestroyFn destroy_fn; /* Destructor (may be NULL) */
} msTypeInfo;

/*
 * Flags packed into 1 byte (matches Nim ORC)
 * Bit layout: [color:2][buffered:1][_reserved:5]
 *
 * Note: is_cyclic is NOT stored here - it's compile-time determined
 * and passed via TypeInfo by the caller.
 */
typedef struct {
    uint8_t color : 2;      /* Bacon-Rajan color (BLACK, PURPLE, GRAY, WHITE) */
    uint8_t buffered : 1;   /* In root list for cycle detection */
    uint8_t scheduled : 1;  /* Scheduled for collection (in to_free list) */
    uint8_t _reserved : 4;  /* Reserved for future use */
} msFlags;

/*
 * Reference Header (8 bytes)
 * Layout: [rc:4][flags:1][type_id:3]
 *
 * type_id enables looking up TypeInfo during cycle tracing.
 * This allows tracing children that weren't directly decremented.
 * 24-bit type_id supports up to 16 million types.
 */
typedef struct {
    uint32_t rc;                    /* Reference count */
    msFlags flags;                  /* Flags */
    uint8_t type_id[3];             /* Type registry index (24-bit, little-endian) */
} msRefHeader;

/* Helper to get/set type_id (24-bit value from 3 bytes) */
static inline uint32_t ms_get_type_id(msRefHeader* header) {
    return (uint32_t)header->type_id[0] |
           ((uint32_t)header->type_id[1] << 8) |
           ((uint32_t)header->type_id[2] << 16);
}

static inline void ms_set_type_id(msRefHeader* header, uint32_t id) {
    header->type_id[0] = (uint8_t)(id & 0xFF);
    header->type_id[1] = (uint8_t)((id >> 8) & 0xFF);
    header->type_id[2] = (uint8_t)((id >> 16) & 0xFF);
}

/*
 * Configuration
 */
#ifndef MS_MAX_ROOTS
#define MS_MAX_ROOTS 1024
#endif

#ifndef MS_CYCLE_THRESHOLD
#define MS_CYCLE_THRESHOLD 100
#endif

#ifndef MS_MAX_TYPES
#define MS_MAX_TYPES 4096
#endif

/*
 * ============================================================================
 * STORAGE DECLARATIONS
 * ============================================================================
 *
 * For multi-TU builds: globals are declared extern here, defined in the
 * implementation section below (when MS_ORC_IMPLEMENTATION is defined).
 *
 * For single-file builds: if MS_ORC_IMPLEMENTATION isn't defined anywhere,
 * we auto-define it so the header works standalone.
 */

/* Auto-define implementation for single-file usage */
#ifndef MS_ORC_EXTERN
    #ifdef MS_ORC_IMPLEMENTATION
        #define MS_ORC_EXTERN
    #else
        #define MS_ORC_EXTERN extern
    #endif
#endif

/*
 * Type Registry - maps type_id to TypeInfo
 * Type ID 0 is reserved for "unknown type"
 */
MS_ORC_EXTERN const msTypeInfo* ms_type_registry[MS_MAX_TYPES];
MS_ORC_EXTERN size_t ms_type_count;

/*
 * Register a type and get its ID (idempotent - returns existing ID if already registered)
 */
static inline uint32_t ms_register_type(const msTypeInfo* type_info) {
    if (type_info == NULL) return 0;

    /* Check if already registered */
    for (size_t i = 1; i < ms_type_count; i++) {
        if (ms_type_registry[i] == type_info) {
            return (uint32_t)i;
        }
    }

    /* Register new type */
    if (ms_type_count >= MS_MAX_TYPES) {
        /* Registry full - fall back to no type tracking */
        return 0;
    }

    uint32_t id = (uint32_t)ms_type_count;
    ms_type_registry[id] = type_info;
    ms_type_count++;
    return id;
}

/*
 * Look up TypeInfo by type_id
 */
static inline const msTypeInfo* ms_get_type_info(uint32_t type_id) {
    if (type_id == 0 || type_id >= ms_type_count) return NULL;
    return ms_type_registry[type_id];
}

/*
 * Root entry: stores header pointer for cycle collection
 * (TypeInfo now looked up via type_id in header)
 */
typedef struct {
    msRefHeader* header;
} msRootEntry;

/*
 * Global state (see STORAGE DECLARATIONS above for multi-TU pattern)
 */
MS_ORC_EXTERN msRootEntry ms_roots[MS_MAX_ROOTS];
MS_ORC_EXTERN size_t ms_root_count;
MS_ORC_EXTERN uint64_t ms_stats_allocations;
MS_ORC_EXTERN uint64_t ms_stats_deallocations;
MS_ORC_EXTERN uint64_t ms_stats_cycle_collections;
MS_ORC_EXTERN uint64_t ms_stats_acyclic_skipped;

/*
 * ============================================================================
 * LEAK DETECTION DEBUG MODE
 * ============================================================================
 *
 * When MS_DEBUG_LEAKS is defined, all allocations are tracked with file:line
 * info. Call ms_report_leaks() at program exit to see unreleased memory.
 *
 * Usage:
 *   #define MS_DEBUG_LEAKS
 *   #define MS_ORC_IMPLEMENTATION
 *   #include "orc.h"
 *
 *   // ... your code ...
 *
 *   // At program exit:
 *   ms_report_leaks();  // Prints all unreleased allocations
 *
 * For automatic reporting, use MS_DEBUG_LEAKS_ATEXIT:
 *   #define MS_DEBUG_LEAKS
 *   #define MS_DEBUG_LEAKS_ATEXIT
 *   #include "orc.h"
 *   // ms_report_leaks() called automatically at exit
 */
#ifdef MS_DEBUG_LEAKS

#include <stdio.h>

#ifndef MS_MAX_TRACKED_ALLOCS
#define MS_MAX_TRACKED_ALLOCS 65536
#endif

/* Allocation tracking entry */
typedef struct {
    void* ptr;              /* User pointer (after header) */
    const char* file;       /* Source file */
    int line;               /* Source line */
    size_t size;            /* Allocation size */
    const char* type_name;  /* Type name if known */
} msAllocInfo;

/* Global tracking state */
MS_ORC_EXTERN msAllocInfo ms_alloc_tracker[MS_MAX_TRACKED_ALLOCS];
MS_ORC_EXTERN size_t ms_alloc_tracker_count;
MS_ORC_EXTERN size_t ms_peak_allocations;
MS_ORC_EXTERN size_t ms_total_bytes_allocated;

#endif /* MS_DEBUG_LEAKS */

/* Forward declaration */
static inline void ms_collect_cycles(void);

/*
 * Get RefHeader from user data pointer
 */
static inline msRefHeader* ms_get_header(void* ptr) {
    return (msRefHeader*)((char*)ptr - sizeof(msRefHeader));
}

/*
 * Allocate memory with DRC header
 * type_id is set to 0 (unknown) - call ms_set_type after allocation
 * or use ms_alloc_typed for typed allocation
 */
static inline void* ms_alloc(size_t size) {
    void* mem = malloc(sizeof(msRefHeader) + size);
    if (mem == NULL) return NULL;

    msRefHeader* header = (msRefHeader*)mem;
    header->rc = 1;
    header->flags.color = MS_COLOR_BLACK;
    header->flags.buffered = 0;
    header->flags.scheduled = 0;
    header->flags._reserved = 0;
    ms_set_type_id(header, 0);  /* Unknown type initially */

    ms_stats_allocations++;
    return (char*)mem + sizeof(msRefHeader);
}

/*
 * Set type info for an object (registers type if needed)
 * Should be called once after allocation for cyclic types
 */
#ifndef MS_DEBUG_LEAKS
static inline void ms_set_type(void* ptr, const msTypeInfo* type_info) {
    if (ptr == NULL || type_info == NULL) return;
    msRefHeader* header = ms_get_header(ptr);
    uint32_t type_id = ms_register_type(type_info);
    ms_set_type_id(header, type_id);
}
#endif

/*
 * ============================================================================
 * LEAK DETECTION INLINE FUNCTIONS
 * ============================================================================
 */
#ifdef MS_DEBUG_LEAKS

/* Track an allocation (internal) */
static inline void ms_track_alloc(void* ptr, size_t size, const char* file, int line) {
    if (ms_alloc_tracker_count >= MS_MAX_TRACKED_ALLOCS) {
        fprintf(stderr, "[MS_DEBUG_LEAKS] WARNING: Tracker full at %s:%d\n", file, line);
        return;
    }
    ms_alloc_tracker[ms_alloc_tracker_count] = (msAllocInfo){
        .ptr = ptr,
        .file = file,
        .line = line,
        .size = size,
        .type_name = NULL,
    };
    ms_alloc_tracker_count++;
    ms_total_bytes_allocated += size;
    if (ms_alloc_tracker_count > ms_peak_allocations) {
        ms_peak_allocations = ms_alloc_tracker_count;
    }
}

/* Untrack an allocation (internal) */
static inline void ms_untrack_alloc(void* ptr) {
    for (size_t i = 0; i < ms_alloc_tracker_count; i++) {
        if (ms_alloc_tracker[i].ptr == ptr) {
            ms_alloc_tracker[i] = ms_alloc_tracker[ms_alloc_tracker_count - 1];
            ms_alloc_tracker_count--;
            return;
        }
    }
    fprintf(stderr, "[MS_DEBUG_LEAKS] WARNING: Freeing untracked %p\n", ptr);
}

/* Set type name for tracked allocation */
static inline void ms_track_set_type(void* ptr, const char* type_name) {
    for (size_t i = 0; i < ms_alloc_tracker_count; i++) {
        if (ms_alloc_tracker[i].ptr == ptr) {
            ms_alloc_tracker[i].type_name = type_name;
            return;
        }
    }
}

/* Report all leaked allocations */
static inline void ms_report_leaks(void) {
    if (ms_alloc_tracker_count == 0) {
        printf("[MS_DEBUG_LEAKS] No memory leaks detected.\n");
        printf("[MS_DEBUG_LEAKS] Peak: %zu allocs, Total: %zu bytes\n",
               ms_peak_allocations, ms_total_bytes_allocated);
        return;
    }

    printf("\n============================================================\n");
    printf("[MS_DEBUG_LEAKS] MEMORY LEAK REPORT\n");
    printf("============================================================\n");
    printf("Leaked: %zu allocations\n", ms_alloc_tracker_count);
    printf("Peak: %zu allocations\n", ms_peak_allocations);
    printf("Total allocated: %zu bytes\n", ms_total_bytes_allocated);
    printf("------------------------------------------------------------\n");

    size_t total_leaked = 0;
    for (size_t i = 0; i < ms_alloc_tracker_count; i++) {
        msAllocInfo* info = &ms_alloc_tracker[i];
        printf("  [%zu] %s:%d - %zu bytes",
               i + 1, info->file ? info->file : "?", info->line, info->size);
        if (info->type_name) printf(" (%s)", info->type_name);
        printf(" @ %p\n", info->ptr);
        total_leaked += info->size;
    }

    printf("------------------------------------------------------------\n");
    printf("Total leaked: %zu bytes\n", total_leaked);
    printf("============================================================\n\n");
}

/* Tracked allocation with file:line info */
static inline void* ms_alloc_tracked(size_t size, const char* file, int line) {
    void* mem = malloc(sizeof(msRefHeader) + size);
    if (mem == NULL) return NULL;

    msRefHeader* header = (msRefHeader*)mem;
    header->rc = 1;
    header->flags.color = MS_COLOR_BLACK;
    header->flags.buffered = 0;
    header->flags.scheduled = 0;
    header->flags._reserved = 0;
    ms_set_type_id(header, 0);

    ms_stats_allocations++;
    void* ptr = (char*)mem + sizeof(msRefHeader);
    ms_track_alloc(ptr, size, file, line);
    return ptr;
}

/* Tracked ms_set_type */
static inline void ms_set_type_tracked(void* ptr, const msTypeInfo* type_info) {
    if (ptr == NULL || type_info == NULL) return;
    msRefHeader* header = ms_get_header(ptr);
    uint32_t type_id = ms_register_type(type_info);
    ms_set_type_id(header, type_id);
    ms_track_set_type(ptr, type_info->name);
}

/* Override ms_alloc and ms_set_type with tracked versions */
#undef ms_alloc
#define ms_alloc(size) ms_alloc_tracked(size, __FILE__, __LINE__)
#define ms_set_type(ptr, type_info) ms_set_type_tracked(ptr, type_info)

#endif /* MS_DEBUG_LEAKS */

/*
 * Increment reference count
 */
static inline void ms_incref(void* ptr) {
    if (ptr == NULL) return;

    msRefHeader* header = ms_get_header(ptr);
    header->rc++;
    header->flags.color = MS_COLOR_BLACK;
}

/*
 * Add to cycle roots (internal)
 * TypeInfo is looked up from header's type_id
 */
static inline void ms_add_to_roots(msRefHeader* header) {
    if (header->flags.buffered) return;
    if (ms_root_count >= MS_MAX_ROOTS) return;

    header->flags.buffered = 1;
    ms_roots[ms_root_count].header = header;
    ms_root_count++;
}

/*
 * Remove from cycle roots (internal)
 */
static inline void ms_remove_from_roots(msRefHeader* header) {
    if (!header->flags.buffered) return;

    /* Find and remove (swap with last) */
    for (size_t i = 0; i < ms_root_count; i++) {
        if (ms_roots[i].header == header) {
            ms_roots[i] = ms_roots[ms_root_count - 1];
            ms_root_count--;
            break;
        }
    }
    header->flags.buffered = 0;
}

/*
 * Free object (internal)
 * Looks up type_info from header's type_id if not provided
 */
static inline void ms_free_object(void* ptr, msRefHeader* header, const msTypeInfo* type_info) {
    /* Look up type from registry if not provided */
    if (type_info == NULL) {
        uint32_t type_id = ms_get_type_id(header);
        type_info = ms_get_type_info(type_id);
    }

    /* Call destructor if present */
    if (type_info && type_info->destroy_fn) {
        type_info->destroy_fn(ptr);
    }

    /* Remove from roots if present */
    if (header->flags.buffered) {
        ms_remove_from_roots(header);
    }

#ifdef MS_DEBUG_LEAKS
    /* Untrack this allocation */
    ms_untrack_alloc(ptr);
#endif

    /* Free memory */
    free(header);
    ms_stats_deallocations++;
}

/*
 * Decrement reference count, free if rc=0 (simple, no cycle check)
 * Use for acyclic types or when caller knows no cycle possible.
 */
static inline void ms_decref(void* ptr) {
    if (ptr == NULL) return;

    msRefHeader* header = ms_get_header(ptr);

    #ifdef DEBUG
    if (header->rc == 0) {
        fprintf(stderr, "ERROR: ms_decref called on freed pointer\n");
        abort();
    }
    #endif

    header->rc--;

    if (header->rc == 0) {
        ms_free_object(ptr, header, NULL);
    } else {
        header->flags.color = MS_COLOR_BLACK;
    }
}

/*
 * Decrement with cycle check (caller provides type info)
 * Adds to roots if rc > 0 and type is cyclic.
 *
 * IMPORTANT: Also sets the type_id in header so that cycle tracing
 * can find TypeInfo for this object and its children.
 */
static inline void ms_decref_typed(void* ptr, const msTypeInfo* type_info) {
    if (ptr == NULL) return;

    msRefHeader* header = ms_get_header(ptr);

    #ifdef DEBUG
    if (header->rc == 0) {
        fprintf(stderr, "ERROR: ms_decref_typed called on freed pointer\n");
        abort();
    }
    #endif

    /* Register type and store type_id in header for cycle tracing */
    if (type_info != NULL) {
        uint32_t type_id = ms_register_type(type_info);
        ms_set_type_id(header, type_id);
    }

    header->rc--;

    if (header->rc == 0) {
        ms_free_object(ptr, header, type_info);
    } else {
        /* Skip cycle detection for acyclic types (Nim ORC optimization) */
        if (!type_info || !type_info->is_cyclic) {
            ms_stats_acyclic_skipped++;
            return;
        }

        /* Potential cycle root */
        header->flags.color = MS_COLOR_PURPLE;
        ms_add_to_roots(header);

        /* Trigger collection if threshold reached */
        if (ms_root_count >= MS_CYCLE_THRESHOLD) {
            ms_collect_cycles();
        }
    }
}

/*
 * Mark gray callback - decrement children's RC during trial deletion
 * Uses type_id from header to look up TypeInfo for recursive tracing
 */
static void ms_mark_gray_callback(void* child) {
    msRefHeader* header = ms_get_header(child);
#ifdef DEBUG_ORC
    printf("[ORC]   mark_gray_callback: child rc=%u -> ", header->rc);
#endif
    if (header->rc > 0) header->rc--;
#ifdef DEBUG_ORC
    printf("%u\n", header->rc);
#endif
    /* Mark child gray and recursively trace if possible */
    if (header->flags.color != MS_COLOR_GRAY) {
        header->flags.color = MS_COLOR_GRAY;

        /* Look up child's type from type_id stored in header */
        uint32_t type_id = ms_get_type_id(header);
        const msTypeInfo* child_type = ms_get_type_info(type_id);
        if (child_type && child_type->trace_fn) {
            void* child_obj = (char*)header + sizeof(msRefHeader);
#ifdef DEBUG_ORC
            printf("[ORC]     Recursively tracing child %s\n", child_type->name);
#endif
            child_type->trace_fn(child_obj, ms_mark_gray_callback);
        }
    }
}

/*
 * Mark object gray (trial deletion) - entry point from collect_cycles
 * type_info is used to call trace_fn
 */
static void ms_mark_gray(msRefHeader* header, void* obj, const msTypeInfo* type_info) {
    if (header->flags.color != MS_COLOR_GRAY) {
        header->flags.color = MS_COLOR_GRAY;

        /* Trace children - decrement their RC and recursively trace */
        if (type_info && type_info->trace_fn) {
#ifdef DEBUG_ORC
            printf("[ORC]   Calling trace_fn for %s\n", type_info->name);
#endif
            type_info->trace_fn(obj, ms_mark_gray_callback);
        }
#ifdef DEBUG_ORC
        else {
            printf("[ORC]   No trace_fn! type_info=%p\n", (void*)type_info);
        }
#endif
    }
}

/*
 * Scan black callback - restore children's RC and recursively trace
 *
 * IMPORTANT: Must recurse to match mark_gray's recursive decrement.
 * Without recursion, RCs become corrupted for deep object graphs.
 */
static void ms_scan_black_callback(void* child) {
    msRefHeader* header = ms_get_header(child);
    header->rc++;

    if (header->flags.color != MS_COLOR_BLACK) {
        header->flags.color = MS_COLOR_BLACK;

        /* Recursively trace children to restore their RCs too */
        uint32_t type_id = ms_get_type_id(header);
        const msTypeInfo* child_type = ms_get_type_info(type_id);
        if (child_type && child_type->trace_fn) {
            void* child_obj = (char*)header + sizeof(msRefHeader);
            child_type->trace_fn(child_obj, ms_scan_black_callback);
        }
    }
}

/*
 * Mark object black (live)
 */
static void ms_scan_black(msRefHeader* header, void* obj, const msTypeInfo* type_info) {
    header->flags.color = MS_COLOR_BLACK;

    if (type_info && type_info->trace_fn) {
        type_info->trace_fn(obj, ms_scan_black_callback);
    }
}

/*
 * Scan callback - recursively scan gray children
 */
static void ms_scan_callback(void* child) {
    msRefHeader* header = ms_get_header(child);

    if (header->flags.color == MS_COLOR_GRAY) {
        if (header->rc > 0) {
            /* Child has external refs - mark black and restore children */
            uint32_t type_id = ms_get_type_id(header);
            const msTypeInfo* child_type = ms_get_type_info(type_id);
            void* child_obj = (char*)header + sizeof(msRefHeader);
            ms_scan_black(header, child_obj, child_type);
        } else {
            /* Mark as garbage */
            header->flags.color = MS_COLOR_WHITE;
            /* Continue scanning children */
            uint32_t type_id = ms_get_type_id(header);
            const msTypeInfo* child_type = ms_get_type_info(type_id);
            if (child_type && child_type->trace_fn) {
                void* child_obj = (char*)header + sizeof(msRefHeader);
                child_type->trace_fn(child_obj, ms_scan_callback);
            }
        }
    }
}

/*
 * Scan object - if RC > 0 mark black (live), else mark white (garbage)
 * Also recursively scans children to handle objects not in roots.
 */
static void ms_scan(msRefHeader* header, void* obj, const msTypeInfo* type_info) {
    if (header->flags.color == MS_COLOR_GRAY) {
        if (header->rc > 0) {
            ms_scan_black(header, obj, type_info);
        } else {
            header->flags.color = MS_COLOR_WHITE;
            /* Recursively scan children */
            if (type_info && type_info->trace_fn) {
                type_info->trace_fn(obj, ms_scan_callback);
            }
        }
    }
}

/*
 * Collect (free) a WHITE object and its WHITE children recursively.
 *
 * DESIGN: Two-phase approach for cycle safety
 * - Objects in to_free (scheduled=1) are freed without tracing
 * - Non-root children (scheduled=0) are traced and freed recursively
 *
 * The key insight: In a cycle where all members are roots, they're all in
 * to_free with scheduled=1. We don't trace them to avoid use-after-free
 * when one member's child pointer points to an already-freed member.
 * For non-root children (only reachable from a root), we trace normally.
 */
static void ms_collect_white_callback(void* child);

/*
 * Hash set for tracking freed pointers during collection.
 * Uses open addressing with linear probing for O(1) average insert/lookup.
 * This prevents use-after-free when tracing cycles with already-freed members.
 */
static void** ms_freed_buckets = NULL;
static size_t ms_freed_capacity = 0;
static size_t ms_freed_count = 0;

/* FNV-1a hash for pointers */
static inline size_t ms_ptr_hash(void* ptr) {
    uintptr_t val = (uintptr_t)ptr;
    /* Mix bits for better distribution */
    val ^= val >> 33;
    val *= 0xff51afd7ed558ccdULL;
    val ^= val >> 33;
    val *= 0xc4ceb9fe1a85ec53ULL;
    val ^= val >> 33;
    return (size_t)val;
}

static void ms_freed_init(size_t expected_count) {
    /* Size to ~50% load factor for good performance */
    ms_freed_capacity = expected_count * 2;
    if (ms_freed_capacity < 16) ms_freed_capacity = 16;
    ms_freed_buckets = (void**)calloc(ms_freed_capacity, sizeof(void*));
    ms_freed_count = 0;
}

static void ms_freed_cleanup(void) {
    if (ms_freed_buckets) {
        free(ms_freed_buckets);
        ms_freed_buckets = NULL;
    }
    ms_freed_capacity = 0;
    ms_freed_count = 0;
}

static void ms_freed_add(void* ptr) {
    if (ms_freed_buckets == NULL || ms_freed_count >= ms_freed_capacity / 2) {
        return;  /* Safety: don't overflow */
    }
    size_t idx = ms_ptr_hash(ptr) % ms_freed_capacity;
    /* Linear probing */
    while (ms_freed_buckets[idx] != NULL) {
        if (ms_freed_buckets[idx] == ptr) return;  /* Already present */
        idx = (idx + 1) % ms_freed_capacity;
    }
    ms_freed_buckets[idx] = ptr;
    ms_freed_count++;
}

static bool ms_freed_contains(void* ptr) {
    if (ms_freed_buckets == NULL) return false;
    size_t idx = ms_ptr_hash(ptr) % ms_freed_capacity;
    size_t start = idx;
    /* Linear probing */
    while (ms_freed_buckets[idx] != NULL) {
        if (ms_freed_buckets[idx] == ptr) return true;
        idx = (idx + 1) % ms_freed_capacity;
        if (idx == start) break;  /* Full circle */
    }
    return false;
}

static void ms_collect_white(msRefHeader* header) {
    /* Only process WHITE objects - skip BLACK/GRAY/already-collected */
    if (header->flags.color != MS_COLOR_WHITE) return;

    /* Mark BLACK immediately to prevent re-entry during recursion */
    header->flags.color = MS_COLOR_BLACK;

    uint32_t type_id = ms_get_type_id(header);
    const msTypeInfo* type_info = ms_get_type_info(type_id);
    void* obj = (char*)header + sizeof(msRefHeader);

#ifdef DEBUG_ORC
    printf("[ORC]   Collecting: %s\n", type_info ? type_info->name : "unknown");
#endif

    /* Recursively collect WHITE children that are NOT scheduled.
     * Scheduled children are in to_free and will be freed by the iteration. */
    if (type_info && type_info->trace_fn) {
        type_info->trace_fn(obj, ms_collect_white_callback);
    }

    /* Now free this object (children already freed or scheduled) */
    header->flags.buffered = 0;
    header->flags.scheduled = 0;
    if (type_info && type_info->destroy_fn) {
        type_info->destroy_fn(obj);
    }
#ifdef MS_DEBUG_LEAKS
    ms_untrack_alloc(obj);
#endif
    ms_freed_add(obj);  /* Track freed pointer */
    free(header);
    ms_stats_deallocations++;
}

static void ms_collect_white_callback(void* child) {
    /* Check if already freed (prevents use-after-free in cycles) */
    if (ms_freed_contains(child)) return;

    msRefHeader* header = ms_get_header(child);
    /* Skip children that are scheduled for collection (they're in to_free list
     * and will be freed by the iteration in collect_cycles). */
    if (header->flags.scheduled) return;
    ms_collect_white(header);
}

/*
 * Run Bacon-Rajan cycle collection
 *
 * Three phases:
 * 1. Mark Gray: Trial deletion - decrement children's RC
 * 2. Scan: If RC > 0 → live (BLACK), else → garbage (WHITE)
 * 3. Collect: Recursively free WHITE objects
 *
 * Key insight: Each function guards itself with color checks, making
 * redundant processing harmless. No need for NULL-ing or temporary arrays.
 */
static inline void ms_collect_cycles(void) {
    if (ms_root_count == 0) return;

    ms_stats_cycle_collections++;

#ifdef DEBUG_ORC
    printf("[ORC] collect_cycles: %zu roots\n", ms_root_count);
#endif

    /* Phase 1: Mark gray (trial deletion)
     * - PURPLE roots get mark_gray'd (recursive decrement)
     * - Non-PURPLE roots already processed by recursive mark_gray
     */
    for (size_t i = 0; i < ms_root_count; i++) {
        msRefHeader* header = ms_roots[i].header;
        if (header->flags.color == MS_COLOR_PURPLE) {
            uint32_t type_id = ms_get_type_id(header);
            const msTypeInfo* type_info = ms_get_type_info(type_id);
            void* obj = (char*)header + sizeof(msRefHeader);
#ifdef DEBUG_ORC
            printf("[ORC] Phase1 root[%zu]: PURPLE rc=%u\n", i, header->rc);
#endif
            ms_mark_gray(header, obj, type_info);
        } else {
            /* Already GRAY from recursive mark_gray - just clear buffered flag */
            header->flags.buffered = 0;
#ifdef DEBUG_ORC
            printf("[ORC] Phase1 root[%zu]: already %d, skipped\n", i, header->flags.color);
#endif
        }
    }

    /* Phase 2: Scan - determine live vs garbage
     * - ms_scan checks color==GRAY, so non-GRAY roots are skipped
     * - RC > 0 after trial deletion → live (mark BLACK, restore children)
     * - RC == 0 → garbage (mark WHITE)
     */
    for (size_t i = 0; i < ms_root_count; i++) {
        msRefHeader* header = ms_roots[i].header;
        uint32_t type_id = ms_get_type_id(header);
        const msTypeInfo* type_info = ms_get_type_info(type_id);
        void* obj = (char*)header + sizeof(msRefHeader);
#ifdef DEBUG_ORC
        printf("[ORC] Phase2 root[%zu]: rc=%u color=%d\n", i, header->rc, header->flags.color);
#endif
        ms_scan(header, obj, type_info);
    }

    /* Phase 3: Collect garbage (WHITE objects)
     *
     * CRITICAL: Two-pass approach to avoid use-after-free!
     * When ms_collect_white recursively frees children, those children may also
     * be in the roots array. If we check header->flags.color on a freed header,
     * we get use-after-free. Solution:
     *   Pass 1: Scan all roots while headers are still valid, collect WHITE ones
     *   Pass 2: Free collected WHITE headers (recursive free is now safe)
     */
#ifdef DEBUG_ORC
    printf("[ORC] Phase3: Collecting garbage\n");
#endif

    /* Pass 1: Collect WHITE roots into to_free list (all headers still valid) */
    msRefHeader* to_free[MS_MAX_ROOTS];
    size_t to_free_count = 0;

    for (size_t i = 0; i < ms_root_count; i++) {
        msRefHeader* header = ms_roots[i].header;
#ifdef DEBUG_ORC
        printf("[ORC] Phase3 root[%zu]: rc=%u color=%d\n", i, header->rc, header->flags.color);
#endif
        if (header->flags.color == MS_COLOR_WHITE) {
            to_free[to_free_count++] = header;
        } else {
            /* Live object - reset to clean state */
            header->flags.color = MS_COLOR_BLACK;
            header->flags.buffered = 0;
        }
    }

    /* Clear roots before freeing (prevent re-add during recursive free) */
    ms_root_count = 0;

    /* Mark all to_free headers as scheduled (prevents recursive free from
     * processing them - they'll be freed by the iteration below) */
    for (size_t i = 0; i < to_free_count; i++) {
        to_free[i]->flags.scheduled = 1;
    }

    /* Initialize freed pointer tracking (prevents use-after-free in cycles) */
    ms_freed_init(to_free_count * 2);  /* Extra capacity for non-root children */

    /* Pass 2: Free all collected WHITE headers */
    for (size_t i = 0; i < to_free_count; i++) {
        ms_collect_white(to_free[i]);
    }

    /* Cleanup freed pointer tracking */
    ms_freed_cleanup();

#ifdef DEBUG_ORC
    printf("[ORC] Collect done\n");
#endif
}

/*
 * Query functions
 */
static inline uint32_t ms_getrc(void* ptr) {
    if (ptr == NULL) return 0;
    return ms_get_header(ptr)->rc;
}

static inline msColor ms_getcolor(void* ptr) {
    if (ptr == NULL) return MS_COLOR_BLACK;
    return (msColor)ms_get_header(ptr)->flags.color;
}

/*
 * Note: ms_is_cyclic removed - cyclicity is now compile-time determined
 * and passed via TypeInfo. Use type_info->is_cyclic instead.
 */

static inline bool ms_is_in_roots(void* ptr) {
    if (ptr == NULL) return false;
    return ms_get_header(ptr)->flags.buffered;
}

static inline size_t ms_get_root_count(void) {
    return ms_root_count;
}

/*
 * Clear all roots (for testing - ensures clean state between tests)
 */
static inline void ms_clear_roots(void) {
    for (size_t i = 0; i < ms_root_count; i++) {
        ms_roots[i].header->flags.buffered = 0;
    }
    ms_root_count = 0;
}

/*
 * Move semantics helpers
 */
static inline void* ms_sink(void* ptr) {
    return ptr; /* No-op, ownership transferred */
}

static inline void* ms_clone(void* ptr) {
    ms_incref(ptr);
    return ptr;
}

/*
 * Statistics
 */
typedef struct {
    uint64_t allocations;
    uint64_t deallocations;
    uint64_t cycle_collections;
    uint64_t acyclic_skipped;
    size_t root_count;
} msStats;

static inline msStats ms_get_stats(void) {
    return (msStats){
        .allocations = ms_stats_allocations,
        .deallocations = ms_stats_deallocations,
        .cycle_collections = ms_stats_cycle_collections,
        .acyclic_skipped = ms_stats_acyclic_skipped,
        .root_count = ms_root_count,
    };
}

#ifdef __cplusplus
}
#endif

/*
 * ============================================================================
 * IMPLEMENTATION SECTION
 * ============================================================================
 *
 * This section is only compiled when MS_ORC_IMPLEMENTATION is defined.
 * Define it in exactly ONE .c file before including this header.
 */
#ifdef MS_ORC_IMPLEMENTATION

/* Storage definitions (declared extern above) */
const msTypeInfo* ms_type_registry[MS_MAX_TYPES] = {0};
size_t ms_type_count = 1;  /* Start at 1, 0 is reserved for "unknown" */
msRootEntry ms_roots[MS_MAX_ROOTS] = {0};
size_t ms_root_count = 0;
uint64_t ms_stats_allocations = 0;
uint64_t ms_stats_deallocations = 0;
uint64_t ms_stats_cycle_collections = 0;
uint64_t ms_stats_acyclic_skipped = 0;

#ifdef MS_DEBUG_LEAKS
/* Leak tracking storage */
msAllocInfo ms_alloc_tracker[MS_MAX_TRACKED_ALLOCS] = {0};
size_t ms_alloc_tracker_count = 0;
size_t ms_peak_allocations = 0;
size_t ms_total_bytes_allocated = 0;

#ifdef MS_DEBUG_LEAKS_ATEXIT
/* Auto-register ms_report_leaks at exit */
__attribute__((constructor))
static void ms_register_leak_report(void) {
    atexit(ms_report_leaks);
}
#endif /* MS_DEBUG_LEAKS_ATEXIT */

#endif /* MS_DEBUG_LEAKS */

#endif /* MS_ORC_IMPLEMENTATION */

#endif /* METASCRIPT_ORC_H */
